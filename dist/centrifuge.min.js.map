{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///centrifuge.min.js","webpack:///webpack/bootstrap 6b3b6ab76ba6fd6b7ca2","webpack:///./src/centrifuge.js","webpack:///./src/subscription.js","webpack:///./src/json.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/index.js","webpack:///./node_modules/events/events.js","webpack:///./src/utils.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","10","global","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","Centrifuge","undefined","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_events","_events2","_subscription","_subscription2","_json","_utils","_EventEmitter","url","options","_this","getPrototypeOf","_url","_sockjs","_isSockjs","_binary","_methodType","_pushType","_encoder","_decoder","_status","_reconnect","_reconnecting","_transport","_transportName","_transportClosed","_messageId","_clientID","_refreshRequired","_subs","_lastSeq","_lastGen","_lastEpoch","_messages","_isBatching","_isSubscribeBatching","_privateChannels","_numRefreshFailed","_refreshTimeout","_pingTimeout","_pongTimeout","_subRefreshTimeouts","_retries","_callbacks","_latency","_latencyStart","_connectData","_token","_xhrID","_xhrs","_config","debug","sockjs","promise","minRetry","maxRetry","timeout","ping","pingInterval","pongWaitTimeout","privateChannelPrefix","onTransportClose","sockjsServer","sockjsTransports","refreshEndpoint","refreshHeaders","refreshParams","refreshData","refreshAttempts","refreshInterval","onRefreshFailed","onRefresh","subscribeEndpoint","subscribeHeaders","subscribeParams","subRefreshInterval","onPrivateSubscribe","_configure","token","data","params","headers","callback","_this2","query","_debug","JSON","stringify","xhr","XMLHttpRequest","ActiveXObject","encodeURIComponent","open","withCredentials","setRequestHeader","headerName","onreadystatechange","readyState","status","parsed","parse","responseText","e","error","_log","setTimeout","send","log","arguments","WebSocket","format","_formatOverride","Error","JsonMethodType","JsonPushType","JsonEncoder","JsonDecoder","configuration","assign","startsWith","indexOf","_setFormat","SockJS","newStatus","interval","backoff","xhrID","abort","reconnect","_stopPing","id","callbacks","clearTimeout","errback","_createErrorObject","channel","sub","_isSuccess","_triggerUnsubscribe","_recover","_setSubscribing","_setUnsubscribed","_abortInflightXHRs","_clearSubRefreshTimeout","transport","OPEN","commands","_isTransportOpen","command","encodeCommands","_this3","sockjsOptions","transports","server","_websocketSupported","binaryType","onopen","onheartbeat","_restartPing","msg","Date","_call","then","result","_connectResponse","decodeCommandResult","CONNECT","next","err","code","_disconnect","onerror","onclose","closeEvent","reason","needReconnect","advice","event","_getRetryInterval","_refresh","_connect","onmessage","_dataReceived","_this4","method","RPC","isConnected","Promise","reject","SEND","_transportSend","resolve","PUBLISH","_this5","replies","decodeReplies","_dispatchReply","_this6","_addMessage","_registerCall","_setStatus","_setupTransport","shouldReconnect","_isDisconnected","_clearConnectedState","emit","close","_this7","_refreshFailed","clientID","_newXHRID","cb","resp","jitter","Math","round","random","max","REFRESH","_refreshResponse","_refreshError","context","_ajax","_this8","_this9","expires","client","_getTTLMilliseconds","ttl","_this10","channelsData","channels","channelData","SUB_REFRESH","_getSub","_subRefreshResponse","_subRefreshError","_this11","subRefreshTimeout","_subRefresh","_this12","isResubscribe","_this13","_setNew","SUBSCRIBE","startSubscribeBatching","_subscribe","stopSubscribeBatching","_needRecover","recover","seq","_getLastSeq","gen","_getLastGen","epoch","_getLastEpoch","_subscribeResponse","_subscribeError","UNSUBSCRIBE","min","_this14","wasReconnecting","_resetRetry","getTime","startBatching","_shouldResubscribe","stopBatching","_startPing","ctx","latency","_this15","_isSubscribing","message","_setSubscribeError","_this16","recovered","_setSubscribeSuccess","pubs","publications","reverse","_handlePublication","recoverable","_recoverable","reply","errorExists","join","leave","unsub","unsubscribe","resubscribe","subscribe","pub","push","decodePush","type","PUBLICATION","decodePushData","MESSAGE","_handleMessage","JOIN","_handleJoin","LEAVE","_handleLeave","UNSUB","_handleUnsub","_handleReply","_handlePush","messages","slice","_this17","PING","_pingResponse","lastSeq","lastGen","lastEpoch","_this18","isFunction","_nextMessageId","_isConnected","_ping","_flush","_this19","authChannels","batch","_ret2","events","currentSub","_setEvents","_isUnsubscribed","11","_STATE_NEW","Subscription","centrifuge","_centrifuge","_error","_isResubscribe","_ready","_subscriptionPromise","_noResubscribe","_initializePromise","_promises","on","errContext","_resolve","_reject","toString","knownEvents","ev","successContext","_getSubscribeSuccessContext","to","_getSubscribeErrorContext","noResubscribe","needTrigger","subscribeErrorContext","_unsubscribe","subPromise","_isError","res","rej","_methodCall","PRESENCE","PRESENCE_STATS","HISTORY","12","encodedCommands","encodedReplies","split","methodType","pushType","3","g","Function","eval","window","31","6","EventEmitter","_maxListeners","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","er","handler","len","args","listeners","Array","apply","addListener","listener","newListener","warned","console","trace","once","removeListener","fired","list","position","splice","removeAllListeners","listenerCount","evlistener","emitter","7","prefix","lastIndexOf","level","logger","step","pow","floor"],"mappings":"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","file":"centrifuge.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 31);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Centrifuge = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(6);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _subscription = __webpack_require__(11);\n\nvar _subscription2 = _interopRequireDefault(_subscription);\n\nvar _json = __webpack_require__(12);\n\nvar _utils = __webpack_require__(7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _errorTimeout = 'timeout';\nvar _errorConnectionClosed = 'connection closed';\n\nvar Centrifuge = exports.Centrifuge = function (_EventEmitter) {\n  _inherits(Centrifuge, _EventEmitter);\n\n  function Centrifuge(url, options) {\n    _classCallCheck(this, Centrifuge);\n\n    var _this = _possibleConstructorReturn(this, (Centrifuge.__proto__ || Object.getPrototypeOf(Centrifuge)).call(this));\n\n    _this._url = url;\n    _this._sockjs = null;\n    _this._isSockjs = false;\n    _this._binary = false;\n    _this._methodType = null;\n    _this._pushType = null;\n    _this._encoder = null;\n    _this._decoder = null;\n    _this._status = 'disconnected';\n    _this._reconnect = true;\n    _this._reconnecting = false;\n    _this._transport = null;\n    _this._transportName = null;\n    _this._transportClosed = true;\n    _this._messageId = 0;\n    _this._clientID = null;\n    _this._refreshRequired = false;\n    _this._subs = {};\n    _this._lastSeq = {};\n    _this._lastGen = {};\n    _this._lastEpoch = {};\n    _this._messages = [];\n    _this._isBatching = false;\n    _this._isSubscribeBatching = false;\n    _this._privateChannels = {};\n    _this._numRefreshFailed = 0;\n    _this._refreshTimeout = null;\n    _this._pingTimeout = null;\n    _this._pongTimeout = null;\n    _this._subRefreshTimeouts = {};\n    _this._retries = 0;\n    _this._callbacks = {};\n    _this._latency = null;\n    _this._latencyStart = null;\n    _this._connectData = null;\n    _this._token = null;\n    _this._xhrID = 0;\n    _this._xhrs = {};\n    _this._config = {\n      debug: false,\n      sockjs: null,\n      promise: null,\n      minRetry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      ping: true,\n      pingInterval: 25000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: ['websocket', 'xdr-streaming', 'xhr-streaming', 'eventsource', 'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 1000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      subscribeEndpoint: '/centrifuge/subscribe',\n      subscribeHeaders: {},\n      subscribeParams: {},\n      subRefreshInterval: 1000,\n      onPrivateSubscribe: null\n    };\n    _this._configure(options);\n    return _this;\n  }\n\n  _createClass(Centrifuge, [{\n    key: 'setToken',\n    value: function setToken(token) {\n      this._token = token;\n    }\n  }, {\n    key: 'setConnectData',\n    value: function setConnectData(data) {\n      this._connectData = data;\n    }\n  }, {\n    key: '_ajax',\n    value: function _ajax(url, params, headers, data, callback) {\n      var _this2 = this;\n\n      var query = '';\n      this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n      var xhr = global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP');\n\n      for (var i in params) {\n        if (params.hasOwnProperty(i)) {\n          if (query.length > 0) {\n            query += '&';\n          }\n          query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n        }\n      }\n      if (query.length > 0) {\n        query = '?' + query;\n      }\n      xhr.open('POST', url + query, true);\n      if ('withCredentials' in xhr) {\n        xhr.withCredentials = true;\n      }\n\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      for (var headerName in headers) {\n        if (headers.hasOwnProperty(headerName)) {\n          xhr.setRequestHeader(headerName, headers[headerName]);\n        }\n      }\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            var _data = void 0,\n                parsed = false;\n            try {\n              _data = JSON.parse(xhr.responseText);\n              parsed = true;\n            } catch (e) {\n              callback({\n                error: 'Invalid JSON. Data was: ' + xhr.responseText,\n                status: 200,\n                data: null\n              });\n            }\n            if (parsed) {\n              // prevents double execution.\n              callback({\n                data: _data,\n                status: 200\n              });\n            }\n          } else {\n            _this2._log('wrong status code in AJAX response', xhr.status);\n            callback({\n              status: xhr.status,\n              data: null\n            });\n          }\n        }\n      };\n      setTimeout(function () {\n        return xhr.send(JSON.stringify(data));\n      }, 20);\n      return xhr;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      (0, _utils.log)('info', arguments);\n    }\n  }, {\n    key: '_debug',\n    value: function _debug() {\n      if (this._config.debug === true) {\n        (0, _utils.log)('debug', arguments);\n      }\n    }\n  }, {\n    key: '_websocketSupported',\n    value: function _websocketSupported() {\n      return !(typeof WebSocket !== 'function' && (typeof WebSocket === 'undefined' ? 'undefined' : _typeof(WebSocket)) !== 'object');\n    }\n  }, {\n    key: '_setFormat',\n    value: function _setFormat(format) {\n      if (this._formatOverride(format)) {\n        return;\n      }\n      if (format === 'protobuf') {\n        throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n      }\n      this._binary = false;\n      this._methodType = _json.JsonMethodType;\n      this._pushType = _json.JsonPushType;\n      this._encoder = new _json.JsonEncoder();\n      this._decoder = new _json.JsonDecoder();\n    }\n  }, {\n    key: '_formatOverride',\n    value: function _formatOverride(format) {\n      return false;\n    }\n  }, {\n    key: '_configure',\n    value: function _configure(configuration) {\n      if (!('Promise' in global)) {\n        throw new Error('Promise polyfill required');\n      }\n\n      Object.assign(this._config, configuration || {});\n      this._debug('centrifuge config', this._config);\n\n      if (!this._url) {\n        throw new Error('url required');\n      }\n\n      if ((0, _utils.startsWith)(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n        this._setFormat('protobuf');\n      } else {\n        this._setFormat('json');\n      }\n\n      if ((0, _utils.startsWith)(this._url, 'http')) {\n        this._debug('client will try to connect to SockJS endpoint');\n        if (this._config.sockjs !== null) {\n          this._debug('SockJS explicitly provided in options');\n          this._sockjs = this._config.sockjs;\n        } else {\n          if (typeof global.SockJS === 'undefined') {\n            throw new Error('SockJS not found, use ws:// in url or include SockJS');\n          }\n          this._debug('use globally defined SockJS');\n          this._sockjs = global.SockJS;\n        }\n      } else {\n        this._debug('client will connect to websocket endpoint');\n      }\n    }\n  }, {\n    key: '_setStatus',\n    value: function _setStatus(newStatus) {\n      if (this._status !== newStatus) {\n        this._debug('Status', this._status, '->', newStatus);\n        this._status = newStatus;\n      }\n    }\n  }, {\n    key: '_isDisconnected',\n    value: function _isDisconnected() {\n      return this._status === 'disconnected';\n    }\n  }, {\n    key: '_isConnecting',\n    value: function _isConnecting() {\n      return this._status === 'connecting';\n    }\n  }, {\n    key: '_isConnected',\n    value: function _isConnected() {\n      return this._status === 'connected';\n    }\n  }, {\n    key: '_nextMessageId',\n    value: function _nextMessageId() {\n      return ++this._messageId;\n    }\n  }, {\n    key: '_resetRetry',\n    value: function _resetRetry() {\n      this._debug('reset retries count to 0');\n      this._retries = 0;\n    }\n  }, {\n    key: '_getRetryInterval',\n    value: function _getRetryInterval() {\n      var interval = (0, _utils.backoff)(this._retries, this._config.minRetry, this._config.maxRetry);\n\n      this._retries += 1;\n      return interval;\n    }\n  }, {\n    key: '_abortInflightXHRs',\n    value: function _abortInflightXHRs() {\n      for (var xhrID in this._xhrs) {\n        try {\n          this._xhrs[xhrID].abort();\n        } catch (e) {\n          this._debug('error aborting xhr', e);\n        }\n        delete this._xhrs[xhrID];\n      }\n    }\n  }, {\n    key: '_clearConnectedState',\n    value: function _clearConnectedState(reconnect) {\n      this._clientID = null;\n      this._stopPing();\n\n      // fire errbacks of registered outgoing calls.\n      for (var id in this._callbacks) {\n        if (this._callbacks.hasOwnProperty(id)) {\n          var callbacks = this._callbacks[id];\n          clearTimeout(callbacks.timeout);\n          var errback = callbacks.errback;\n          if (!errback) {\n            continue;\n          }\n          errback(this._createErrorObject('disconnected'));\n        }\n      }\n      this._callbacks = {};\n\n      // fire unsubscribe events\n      for (var channel in this._subs) {\n        if (this._subs.hasOwnProperty(channel)) {\n          var sub = this._subs[channel];\n\n          if (reconnect) {\n            if (sub._isSuccess()) {\n              sub._triggerUnsubscribe();\n              sub._recover = true;\n            }\n            sub._setSubscribing();\n          } else {\n            sub._setUnsubscribed();\n          }\n        }\n      }\n\n      this._abortInflightXHRs();\n\n      // clear refresh timer\n      if (this._refreshTimeout !== null) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n\n      // clear sub refresh timers\n      for (var _channel in this._subRefreshTimeouts) {\n        if (this._subRefreshTimeouts.hasOwnProperty(_channel) && this._subRefreshTimeouts[_channel]) {\n          this._clearSubRefreshTimeout(_channel);\n        }\n      }\n      this._subRefreshTimeouts = {};\n\n      if (!this._reconnect) {\n        // completely clear subscriptions\n        this._subs = {};\n      }\n    }\n  }, {\n    key: '_isTransportOpen',\n    value: function _isTransportOpen() {\n      if (this._isSockjs) {\n        return this._transport && this._transport.transport && this._transport.transport.readyState === this._transport.transport.OPEN;\n      }\n      return this._transport && this._transport.readyState === this._transport.OPEN;\n    }\n  }, {\n    key: '_transportSend',\n    value: function _transportSend(commands) {\n      if (!commands.length) {\n        return true;\n      }\n\n      if (!this._isTransportOpen()) {\n        // resolve pending commands with error if transport is not open\n        for (var command in commands) {\n          var id = command.id;\n          if (!(id in this._callbacks)) {\n            continue;\n          }\n          var callbacks = this._callbacks[id];\n          clearTimeout(this._callbacks[id].timeout);\n          delete this._callbacks[id];\n          var errback = callbacks.errback;\n          errback(this._createErrorObject(_errorConnectionClosed, 0));\n        }\n        return false;\n      }\n      this._transport.send(this._encoder.encodeCommands(commands));\n      return true;\n    }\n  }, {\n    key: '_setupTransport',\n    value: function _setupTransport() {\n      var _this3 = this;\n\n      this._isSockjs = false;\n\n      // detect transport to use - SockJS or Websocket\n      if (this._sockjs !== null) {\n        var sockjsOptions = {\n          transports: this._config.sockjsTransports\n        };\n\n        if (this._config.sockjsServer !== null) {\n          sockjsOptions.server = this._config.sockjsServer;\n        }\n        this._isSockjs = true;\n        this._transport = new this._sockjs(this._url, null, sockjsOptions);\n      } else {\n        if (!this._websocketSupported()) {\n          this._debug('No Websocket support and no SockJS configured, can not connect');\n          return;\n        }\n        this._transport = new WebSocket(this._url);\n        if (this._binary === true) {\n          this._transport.binaryType = 'arraybuffer';\n        }\n      }\n\n      this._transport.onopen = function () {\n        _this3._transportClosed = false;\n\n        if (_this3._isSockjs) {\n          _this3._transportName = 'sockjs-' + _this3._transport.transport;\n          _this3._transport.onheartbeat = function () {\n            return _this3._restartPing();\n          };\n        } else {\n          _this3._transportName = 'websocket';\n        }\n\n        // Can omit method here due to zero value.\n        var msg = {\n          // method: this._methodType.CONNECT\n        };\n\n        if (_this3._token || _this3._connectData) {\n          msg.params = {};\n        }\n\n        if (_this3._token) {\n          msg.params.token = _this3._token;\n        }\n\n        if (_this3._connectData) {\n          msg.params.data = _this3._connectData;\n        }\n\n        _this3._latencyStart = new Date();\n        _this3._call(msg).then(function (result) {\n          _this3._connectResponse(_this3._decoder.decodeCommandResult(_this3._methodType.CONNECT, result.result));\n          if (result.next) {\n            result.next();\n          }\n        }, function (err) {\n          if (err.code === 109) {\n            // token expired.\n            _this3._refreshRequired = true;\n          }\n          _this3._disconnect('connect error', true);\n        });\n      };\n\n      this._transport.onerror = function (error) {\n        _this3._debug('transport level error', error);\n      };\n\n      this._transport.onclose = function (closeEvent) {\n        _this3._transportClosed = true;\n        var reason = _errorConnectionClosed;\n        var needReconnect = true;\n\n        if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n          try {\n            var advice = JSON.parse(closeEvent.reason);\n            _this3._debug('reason is an advice object', advice);\n            reason = advice.reason;\n            needReconnect = advice.reconnect;\n          } catch (e) {\n            reason = closeEvent.reason;\n            _this3._debug('reason is a plain string', reason);\n          }\n        }\n\n        // onTransportClose callback should be executed every time transport was closed.\n        // This can be helpful to catch failed connection events (because our disconnect\n        // event only called once and every future attempts to connect do not fire disconnect\n        // event again).\n        if (_this3._config.onTransportClose !== null) {\n          _this3._config.onTransportClose({\n            event: closeEvent,\n            reason: reason,\n            reconnect: needReconnect\n          });\n        }\n\n        _this3._disconnect(reason, needReconnect);\n\n        if (_this3._reconnect === true) {\n          _this3._reconnecting = true;\n          var interval = _this3._getRetryInterval();\n\n          _this3._debug('reconnect after ' + interval + ' milliseconds');\n          setTimeout(function () {\n            if (_this3._reconnect === true) {\n              if (_this3._refreshRequired) {\n                _this3._refresh();\n              } else {\n                _this3._connect();\n              }\n            }\n          }, interval);\n        }\n      };\n\n      this._transport.onmessage = function (event) {\n        _this3._dataReceived(event.data);\n      };\n    }\n  }, {\n    key: 'rpc',\n    value: function rpc(data) {\n      var _this4 = this;\n\n      var msg = {\n        method: this._methodType.RPC,\n        params: {\n          data: data\n        }\n      };\n\n      if (!this.isConnected()) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n\n      return this._call(msg).then(function (result) {\n        if (result.next) {\n          result.next();\n        }\n        return _this4._decoder.decodeCommandResult(_this4._methodType.RPC, result.result);\n      });\n    }\n  }, {\n    key: 'send',\n    value: function send(data) {\n      var msg = {\n        method: this._methodType.SEND,\n        params: {\n          data: data\n        }\n      };\n\n      if (!this.isConnected()) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n\n      var sent = this._transportSend([msg]); // can send async message to server without id set\n      if (!sent) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      };\n      return Promise.resolve({});\n    }\n  }, {\n    key: 'publish',\n    value: function publish(channel, data) {\n      var msg = {\n        method: this._methodType.PUBLISH,\n        params: {\n          channel: channel,\n          data: data\n        }\n      };\n\n      if (!this.isConnected()) {\n        return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n\n      return this._call(msg).then(function (result) {\n        if (result.next) {\n          result.next();\n        }\n        return {};\n      });\n    }\n  }, {\n    key: '_dataReceived',\n    value: function _dataReceived(data) {\n      var _this5 = this;\n\n      var replies = this._decoder.decodeReplies(data);\n      // we have to guarantee order of events in replies processing - i.e. start processing\n      // next reply only when we finished processing of current one. Without syncing things in\n      // this way we could get wrong publication events order as reply promises resolve\n      // on next loop tick so for loop continues before we finished emitting all reply events.\n      var p = Promise.resolve();\n\n      var _loop = function _loop(i) {\n        if (replies.hasOwnProperty(i)) {\n          p = p.then(function () {\n            return _this5._dispatchReply(replies[i]);\n          });\n        }\n      };\n\n      for (var i in replies) {\n        _loop(i);\n      }\n      this._restartPing();\n    }\n  }, {\n    key: '_call',\n    value: function _call(msg) {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        var id = _this6._addMessage(msg);\n        _this6._registerCall(id, resolve, reject);\n      });\n    }\n  }, {\n    key: '_connect',\n    value: function _connect() {\n      if (this.isConnected()) {\n        this._debug('connect called when already connected');\n        return;\n      }\n      if (this._status === 'connecting') {\n        return;\n      }\n\n      this._debug('start connecting');\n      this._setStatus('connecting');\n      this._clientID = null;\n      this._reconnect = true;\n      this._setupTransport();\n    }\n  }, {\n    key: '_disconnect',\n    value: function _disconnect(reason, shouldReconnect) {\n\n      if (this._isDisconnected()) {\n        return;\n      }\n\n      this._debug('disconnected:', reason, shouldReconnect);\n\n      var reconnect = shouldReconnect || false;\n\n      if (reconnect === false) {\n        this._reconnect = false;\n      }\n\n      this._clearConnectedState(reconnect);\n\n      if (!this._isDisconnected()) {\n        this._setStatus('disconnected');\n        if (this._refreshTimeout) {\n          clearTimeout(this._refreshTimeout);\n          this._refreshTimeout = null;\n        }\n        if (this._reconnecting === false) {\n          this.emit('disconnect', {\n            reason: reason,\n            reconnect: reconnect\n          });\n        }\n      }\n\n      if (!this._transportClosed) {\n        this._transport.close();\n      }\n    }\n  }, {\n    key: '_refreshFailed',\n    value: function _refreshFailed() {\n      this._numRefreshFailed = 0;\n      if (!this._isDisconnected()) {\n        this._disconnect('refresh failed', false);\n      }\n      if (this._config.onRefreshFailed !== null) {\n        this._config.onRefreshFailed();\n      }\n    }\n  }, {\n    key: '_refresh',\n    value: function _refresh() {\n      var _this7 = this;\n\n      // ask application for new connection token.\n      this._debug('refresh token');\n\n      if (this._config.refreshAttempts === 0) {\n        this._debug('refresh attempts set to 0, do not send refresh request at all');\n        this._refreshFailed();\n        return;\n      }\n\n      if (this._refreshTimeout !== null) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n\n      var clientID = this._clientID;\n      var xhrID = this._newXHRID();\n\n      var cb = function cb(resp) {\n        if (xhrID in _this7._xhrs) {\n          delete _this7._xhrs[xhrID];\n        }\n        if (_this7._clientID !== clientID) {\n          return;\n        }\n        if (resp.error || resp.status !== 200) {\n          // We don't perform any connection status related actions here as we are\n          // relying on server that must close connection eventually.\n          if (resp.error) {\n            _this7._debug('error refreshing connection token', resp.error);\n          } else {\n            _this7._debug('error refreshing connection token: wrong status code', resp.status);\n          }\n          _this7._numRefreshFailed++;\n          if (_this7._refreshTimeout !== null) {\n            clearTimeout(_this7._refreshTimeout);\n            _this7._refreshTimeout = null;\n          }\n          if (_this7._config.refreshAttempts !== null && _this7._numRefreshFailed >= _this7._config.refreshAttempts) {\n            _this7._refreshFailed();\n            return;\n          }\n          var jitter = Math.round(Math.random() * 1000 * Math.max(_this7._numRefreshFailed, 20));\n          var interval = _this7._config.refreshInterval + jitter;\n          _this7._refreshTimeout = setTimeout(function () {\n            return _this7._refresh();\n          }, interval);\n          return;\n        }\n        _this7._numRefreshFailed = 0;\n        _this7._token = resp.data.token;\n        if (!_this7._token) {\n          _this7._refreshFailed();\n          return;\n        }\n        if (_this7._isDisconnected() && _this7._reconnect) {\n          _this7._debug('token refreshed, connect from scratch');\n          _this7._connect();\n        } else {\n          _this7._debug('send refreshed token');\n          var msg = {\n            method: _this7._methodType.REFRESH,\n            params: {\n              token: _this7._token\n            }\n          };\n          _this7._call(msg).then(function (result) {\n            _this7._refreshResponse(_this7._decoder.decodeCommandResult(_this7._methodType.REFRESH, result.result));\n            if (result.next) {\n              result.next();\n            }\n          }, function (err) {\n            _this7._refreshError(err);\n          });\n        }\n      };\n\n      if (this._config.onRefresh !== null) {\n        var context = {};\n        this._config.onRefresh(context, cb);\n      } else {\n        var xhr = this._ajax(this._config.refreshEndpoint, this._config.refreshParams, this._config.refreshHeaders, this._config.refreshData, cb);\n        this._xhrs[xhrID] = xhr;\n      }\n    }\n  }, {\n    key: '_refreshError',\n    value: function _refreshError(err) {\n      var _this8 = this;\n\n      this._debug('refresh error', err);\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n      var interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n      this._refreshTimeout = setTimeout(function () {\n        return _this8._refresh();\n      }, interval);\n    }\n  }, {\n    key: '_refreshResponse',\n    value: function _refreshResponse(result) {\n      var _this9 = this;\n\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n      if (result.expires) {\n        this._clientID = result.client;\n        this._refreshTimeout = setTimeout(function () {\n          return _this9._refresh();\n        }, this._getTTLMilliseconds(result.ttl));\n      }\n    }\n  }, {\n    key: '_newXHRID',\n    value: function _newXHRID() {\n      this._xhrID++;\n      return this._xhrID;\n    }\n  }, {\n    key: '_subRefresh',\n    value: function _subRefresh(channel) {\n      var _this10 = this;\n\n      this._debug('refresh subscription token for channel', channel);\n\n      if (this._subRefreshTimeouts[channel] !== undefined) {\n        this._clearSubRefreshTimeout(channel);\n      } else {\n        return;\n      }\n\n      var clientID = this._clientID;\n      var xhrID = this._newXHRID();\n\n      var cb = function cb(resp) {\n        if (xhrID in _this10._xhrs) {\n          delete _this10._xhrs[xhrID];\n        }\n        if (resp.error || resp.status !== 200 || _this10._clientID !== clientID) {\n          return;\n        }\n        var channelsData = {};\n        if (resp.data.channels) {\n          for (var i in data.channels) {\n            var channelData = resp.data.channels[i];\n            if (!channelData.channel) {\n              continue;\n            }\n            channelsData[channelData.channel] = channelData.token;\n          }\n        }\n\n        var token = channelsData[channel];\n        if (!token) {\n          return;\n        }\n        var msg = {\n          method: _this10._methodType.SUB_REFRESH,\n          params: {\n            channel: channel,\n            token: token\n          }\n        };\n\n        var sub = _this10._getSub(channel);\n        if (sub === null) {\n          return;\n        }\n\n        _this10._call(msg).then(function (result) {\n          _this10._subRefreshResponse(channel, _this10._decoder.decodeCommandResult(_this10._methodType.SUB_REFRESH, result.result));\n          if (result.next) {\n            result.next();\n          }\n        }, function (err) {\n          _this10._subRefreshError(channel, err);\n        });\n      };\n\n      var data = {\n        client: this._clientID,\n        channels: [channel]\n      };\n\n      if (this._config.onPrivateSubscribe !== null) {\n        this._config.onPrivateSubscribe({\n          data: data\n        }, cb);\n      } else {\n        var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n        this._xhrs[xhrID] = xhr;\n      }\n    }\n  }, {\n    key: '_clearSubRefreshTimeout',\n    value: function _clearSubRefreshTimeout(channel) {\n      if (this._subRefreshTimeouts[channel] !== undefined) {\n        clearTimeout(this._subRefreshTimeouts[channel]);\n        delete this._subRefreshTimeouts[channel];\n      }\n    }\n  }, {\n    key: '_subRefreshError',\n    value: function _subRefreshError(channel, err) {\n      var _this11 = this;\n\n      this._debug('subscription refresh error', channel, err);\n      this._clearSubRefreshTimeout(channel);\n      var sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n      var jitter = Math.round(Math.random() * 1000);\n      var subRefreshTimeout = setTimeout(function () {\n        return _this11._subRefresh(channel);\n      }, this._config.subRefreshInterval + jitter);\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n      return;\n    }\n  }, {\n    key: '_subRefreshResponse',\n    value: function _subRefreshResponse(channel, result) {\n      var _this12 = this;\n\n      this._debug('subscription refresh success', channel);\n      this._clearSubRefreshTimeout(channel);\n      var sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n      if (result.expires === true) {\n        var subRefreshTimeout = setTimeout(function () {\n          return _this12._subRefresh(channel);\n        }, this._getTTLMilliseconds(result.ttl));\n        this._subRefreshTimeouts[channel] = subRefreshTimeout;\n      }\n      return;\n    }\n  }, {\n    key: '_subscribe',\n    value: function _subscribe(sub, isResubscribe) {\n      var _this13 = this;\n\n      this._debug('subscribing on', sub.channel);\n      var channel = sub.channel;\n\n      if (!(channel in this._subs)) {\n        this._subs[channel] = sub;\n      }\n\n      if (!this.isConnected()) {\n        // subscribe will be called later\n        sub._setNew();\n        return;\n      }\n\n      sub._setSubscribing(isResubscribe);\n\n      var msg = {\n        method: this._methodType.SUBSCRIBE,\n        params: {\n          channel: channel\n        }\n      };\n\n      // If channel name does not start with privateChannelPrefix - then we\n      // can just send subscription message to Centrifuge. If channel name\n      // starts with privateChannelPrefix - then this is a private channel\n      // and we should ask web application backend for permission first.\n      if ((0, _utils.startsWith)(channel, this._config.privateChannelPrefix)) {\n        // private channel.\n        if (this._isSubscribeBatching) {\n          this._privateChannels[channel] = true;\n        } else {\n          this.startSubscribeBatching();\n          this._subscribe(sub);\n          this.stopSubscribeBatching();\n        }\n      } else {\n        var recover = sub._needRecover();\n\n        if (recover === true) {\n          msg.params.recover = true;\n          var seq = this._getLastSeq(channel);\n          if (seq) {\n            msg.params.seq = seq;\n          }\n          var gen = this._getLastGen(channel);\n          if (gen) {\n            msg.params.gen = gen;\n          }\n          var epoch = this._getLastEpoch(channel);\n          if (epoch) {\n            msg.params.epoch = epoch;\n          }\n        }\n\n        this._call(msg).then(function (result) {\n          _this13._subscribeResponse(channel, _this13._decoder.decodeCommandResult(_this13._methodType.SUBSCRIBE, result.result));\n          if (result.next) {\n            result.next();\n          }\n        }, function (err) {\n          _this13._subscribeError(channel, err);\n        });\n      }\n    }\n  }, {\n    key: '_unsubscribe',\n    value: function _unsubscribe(sub) {\n      if (this.isConnected()) {\n        // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n        this._addMessage({\n          method: this._methodType.UNSUBSCRIBE,\n          params: {\n            channel: sub.channel\n          }\n        });\n      }\n    }\n  }, {\n    key: '_getTTLMilliseconds',\n    value: function _getTTLMilliseconds(ttl) {\n      // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n      return Math.min(ttl * 1000, 2147483647);\n    }\n  }, {\n    key: 'getSub',\n    value: function getSub(channel) {\n      return this._getSub(channel);\n    }\n  }, {\n    key: '_getSub',\n    value: function _getSub(channel) {\n      var sub = this._subs[channel];\n      if (!sub) {\n        return null;\n      }\n      return sub;\n    }\n  }, {\n    key: '_connectResponse',\n    value: function _connectResponse(result) {\n      var _this14 = this;\n\n      var wasReconnecting = this._reconnecting;\n      this._reconnecting = false;\n      this._resetRetry();\n      this._refreshRequired = false;\n\n      if (this.isConnected()) {\n        return;\n      }\n\n      if (this._latencyStart !== null) {\n        this._latency = new Date().getTime() - this._latencyStart.getTime();\n        this._latencyStart = null;\n      }\n\n      this._clientID = result.client;\n      this._setStatus('connected');\n\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n      }\n\n      if (result.expires) {\n        this._refreshTimeout = setTimeout(function () {\n          return _this14._refresh();\n        }, this._getTTLMilliseconds(result.ttl));\n      }\n\n      this.startBatching();\n      this.startSubscribeBatching();\n      for (var channel in this._subs) {\n        if (this._subs.hasOwnProperty(channel)) {\n          var sub = this._subs[channel];\n          if (sub._shouldResubscribe()) {\n            this._subscribe(sub, wasReconnecting);\n          }\n        }\n      }\n      this.stopSubscribeBatching();\n      this.stopBatching();\n\n      this._startPing();\n\n      var ctx = {\n        client: result.client,\n        transport: this._transportName,\n        latency: this._latency\n      };\n      if (result.data) {\n        ctx.data = result.data;\n      }\n\n      this.emit('connect', ctx);\n    }\n  }, {\n    key: '_stopPing',\n    value: function _stopPing() {\n      if (this._pongTimeout !== null) {\n        clearTimeout(this._pongTimeout);\n        this._pongTimeout = null;\n      }\n      if (this._pingTimeout !== null) {\n        clearTimeout(this._pingTimeout);\n        this._pingTimeout = null;\n      }\n    }\n  }, {\n    key: '_startPing',\n    value: function _startPing() {\n      var _this15 = this;\n\n      if (this._config.ping !== true || this._config.pingInterval <= 0) {\n        return;\n      }\n      if (!this.isConnected()) {\n        return;\n      }\n\n      this._pingTimeout = setTimeout(function () {\n        if (!_this15.isConnected()) {\n          _this15._stopPing();\n          return;\n        }\n        _this15.ping();\n        _this15._pongTimeout = setTimeout(function () {\n          _this15._disconnect('no ping', true);\n        }, _this15._config.pongWaitTimeout);\n      }, this._config.pingInterval);\n    }\n  }, {\n    key: '_restartPing',\n    value: function _restartPing() {\n      this._stopPing();\n      this._startPing();\n    }\n  }, {\n    key: '_subscribeError',\n    value: function _subscribeError(channel, error) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      if (!sub._isSubscribing()) {\n        return;\n      }\n      if (error.code === 0 && error.message === _errorTimeout) {\n        // client side timeout.\n        this._disconnect('timeout', true);\n        return;\n      }\n      sub._setSubscribeError(error);\n    }\n  }, {\n    key: '_subscribeResponse',\n    value: function _subscribeResponse(channel, result) {\n      var _this16 = this;\n\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      if (!sub._isSubscribing()) {\n        return;\n      }\n\n      var recovered = false;\n      if ('recovered' in result) {\n        recovered = result.recovered;\n      }\n      sub._setSubscribeSuccess(recovered);\n\n      var pubs = result.publications;\n\n      if (pubs && pubs.length > 0) {\n        // handle missed pubs.\n        pubs = pubs.reverse();\n        for (var i in pubs) {\n          if (pubs.hasOwnProperty(i)) {\n            this._handlePublication(channel, pubs[i]);\n          }\n        }\n      } else {\n        if (result.recoverable) {\n          this._lastSeq[channel] = result.seq || 0;\n          this._lastGen[channel] = result.gen || 0;\n        }\n      }\n\n      this._lastEpoch[channel] = result.epoch || '';\n\n      if (result.recoverable) {\n        sub._recoverable = true;\n      }\n\n      if (result.expires === true) {\n        var subRefreshTimeout = setTimeout(function () {\n          return _this16._subRefresh(channel);\n        }, this._getTTLMilliseconds(result.ttl));\n        this._subRefreshTimeouts[channel] = subRefreshTimeout;\n      }\n    }\n  }, {\n    key: '_handleReply',\n    value: function _handleReply(reply, next) {\n      var id = reply.id;\n      var result = reply.result;\n\n      if (!(id in this._callbacks)) {\n        return;\n      }\n      var callbacks = this._callbacks[id];\n      clearTimeout(this._callbacks[id].timeout);\n      delete this._callbacks[id];\n\n      if (!(0, _utils.errorExists)(reply)) {\n        var callback = callbacks.callback;\n        if (!callback) {\n          return;\n        }\n        callback({ result: result, next: next });\n      } else {\n        var errback = callbacks.errback;\n        if (!errback) {\n          return;\n        }\n        errback(reply.error);\n      }\n    }\n  }, {\n    key: '_handleJoin',\n    value: function _handleJoin(channel, join) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      sub.emit('join', join);\n    }\n  }, {\n    key: '_handleLeave',\n    value: function _handleLeave(channel, leave) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      sub.emit('leave', leave);\n    }\n  }, {\n    key: '_handleUnsub',\n    value: function _handleUnsub(channel, unsub) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      sub.unsubscribe();\n      if (unsub.resubscribe === true) {\n        sub.subscribe();\n      }\n    }\n  }, {\n    key: '_handlePublication',\n    value: function _handlePublication(channel, pub) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      if (pub.seq !== undefined) {\n        this._lastSeq[channel] = pub.seq;\n      }\n      if (pub.gen !== undefined) {\n        this._lastGen[channel] = pub.gen;\n      }\n      sub.emit('publish', pub);\n    }\n  }, {\n    key: '_handleMessage',\n    value: function _handleMessage(message) {\n      this.emit('message', message.data);\n    }\n  }, {\n    key: '_handlePush',\n    value: function _handlePush(data, next) {\n      var push = this._decoder.decodePush(data);\n      var type = 0;\n      if ('type' in push) {\n        type = push['type'];\n      }\n      var channel = push.channel;\n\n      if (type === this._pushType.PUBLICATION) {\n        var pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n        this._handlePublication(channel, pub);\n      } else if (type === this._pushType.MESSAGE) {\n        var message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n        this._handleMessage(message);\n      } else if (type === this._pushType.JOIN) {\n        var join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n        this._handleJoin(channel, join);\n      } else if (type === this._pushType.LEAVE) {\n        var leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n        this._handleLeave(channel, leave);\n      } else if (type === this._pushType.UNSUB) {\n        var unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n        this._handleUnsub(channel, unsub);\n      }\n      next();\n    }\n  }, {\n    key: '_dispatchReply',\n    value: function _dispatchReply(reply) {\n      var next;\n      var p = new Promise(function (resolve) {\n        next = resolve;\n      });\n\n      if (reply === undefined || reply === null) {\n        this._debug('dispatch: got undefined or null reply');\n        next();\n        return p;\n      }\n\n      var id = reply.id;\n\n      if (id && id > 0) {\n        this._handleReply(reply, next);\n      } else {\n        this._handlePush(reply.result, next);\n      }\n\n      return p;\n    }\n  }, {\n    key: '_flush',\n    value: function _flush() {\n      var messages = this._messages.slice(0);\n      this._messages = [];\n      this._transportSend(messages);\n    }\n  }, {\n    key: '_ping',\n    value: function _ping() {\n      var _this17 = this;\n\n      var msg = {\n        method: this._methodType.PING\n      };\n      this._call(msg).then(function (result) {\n        _this17._pingResponse(_this17._decoder.decodeCommandResult(_this17._methodType.PING, result.result));\n        result.next();\n      }, function (err) {\n        _this17._debug('ping error', err);\n      });\n    }\n  }, {\n    key: '_pingResponse',\n    value: function _pingResponse(result) {\n      if (!this.isConnected()) {\n        return;\n      }\n      this._stopPing();\n      this._startPing();\n    }\n  }, {\n    key: '_getLastSeq',\n    value: function _getLastSeq(channel) {\n      var lastSeq = this._lastSeq[channel];\n      if (lastSeq) {\n        return lastSeq;\n      }\n      return 0;\n    }\n  }, {\n    key: '_getLastGen',\n    value: function _getLastGen(channel) {\n      var lastGen = this._lastGen[channel];\n      if (lastGen) {\n        return lastGen;\n      }\n      return 0;\n    }\n  }, {\n    key: '_getLastEpoch',\n    value: function _getLastEpoch(channel) {\n      var lastEpoch = this._lastEpoch[channel];\n      if (lastEpoch) {\n        return lastEpoch;\n      }\n      return '';\n    }\n  }, {\n    key: '_createErrorObject',\n    value: function _createErrorObject(message, code) {\n      var errObject = {\n        message: message,\n        code: code || 0\n      };\n\n      return errObject;\n    }\n  }, {\n    key: '_registerCall',\n    value: function _registerCall(id, callback, errback) {\n      var _this18 = this;\n\n      this._callbacks[id] = {\n        callback: callback,\n        errback: errback,\n        timeout: null\n      };\n      this._callbacks[id].timeout = setTimeout(function () {\n        delete _this18._callbacks[id];\n        if ((0, _utils.isFunction)(errback)) {\n          errback(_this18._createErrorObject(_errorTimeout));\n        }\n      }, this._config.timeout);\n    }\n  }, {\n    key: '_addMessage',\n    value: function _addMessage(message) {\n      var id = this._nextMessageId();\n      message.id = id;\n      if (this._isBatching === true) {\n        this._messages.push(message);\n      } else {\n        this._transportSend([message]);\n      }\n      return id;\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._isConnected();\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      this._connect();\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      this._disconnect('client', false);\n    }\n  }, {\n    key: 'ping',\n    value: function ping() {\n      return this._ping();\n    }\n  }, {\n    key: 'startBatching',\n    value: function startBatching() {\n      // start collecting messages without sending them to Centrifuge until flush\n      // method called\n      this._isBatching = true;\n    }\n  }, {\n    key: 'stopBatching',\n    value: function stopBatching() {\n      this._isBatching = false;\n      this._flush();\n    }\n  }, {\n    key: 'startSubscribeBatching',\n    value: function startSubscribeBatching() {\n      // start collecting private channels to create bulk authentication\n      // request to subscribeEndpoint when stopSubscribeBatching will be called\n      this._isSubscribeBatching = true;\n    }\n  }, {\n    key: 'stopSubscribeBatching',\n    value: function stopSubscribeBatching() {\n      var _this19 = this;\n\n      // create request to subscribeEndpoint with collected private channels\n      // to ask if this client can subscribe on each channel\n      this._isSubscribeBatching = false;\n      var authChannels = this._privateChannels;\n      this._privateChannels = {};\n\n      var channels = [];\n\n      for (var channel in authChannels) {\n        if (authChannels.hasOwnProperty(channel)) {\n          var sub = this._getSub(channel);\n          if (!sub) {\n            continue;\n          }\n          channels.push(channel);\n        }\n      }\n\n      if (channels.length === 0) {\n        this._debug('no private channels found, no need to make request');\n        return;\n      }\n\n      var data = {\n        client: this._clientID,\n        channels: channels\n      };\n\n      var clientID = this._clientID;\n      var xhrID = this._newXHRID();\n\n      var cb = function cb(resp) {\n        if (xhrID in _this19._xhrs) {\n          delete _this19._xhrs[xhrID];\n        }\n        if (_this19._clientID !== clientID) {\n          return;\n        }\n        if (resp.error || resp.status !== 200) {\n          _this19._debug('authorization request failed');\n          for (var i in channels) {\n            if (channels.hasOwnProperty(i)) {\n              var _channel2 = channels[i];\n              _this19._subscribeError(_channel2, _this19._createErrorObject('authorization request failed'));\n            }\n          }\n          return;\n        }\n\n        var channelsData = {};\n        if (resp.data.channels) {\n          for (var _i in resp.data.channels) {\n            var channelData = resp.data.channels[_i];\n            if (!channelData.channel) {\n              continue;\n            }\n            channelsData[channelData.channel] = channelData.token;\n          }\n        }\n\n        // try to send all subscriptions in one request.\n        var batch = false;\n\n        if (!_this19._isBatching) {\n          _this19.startBatching();\n          batch = true;\n        }\n\n        for (var _i2 in channels) {\n          if (channels.hasOwnProperty(_i2)) {\n            var _ret2 = function () {\n              var channel = channels[_i2];\n              var token = channelsData[channel];\n\n              if (!token) {\n                // subscription:error\n                _this19._subscribeError(channel, _this19._createErrorObject('permission denied', 103));\n                return 'continue';\n              } else {\n                var msg = {\n                  method: _this19._methodType.SUBSCRIBE,\n                  params: {\n                    channel: channel,\n                    token: token\n                  }\n                };\n\n                var _sub = _this19._getSub(channel);\n                if (_sub === null) {\n                  return 'continue';\n                }\n\n                var recover = _sub._needRecover();\n\n                if (recover === true) {\n                  msg.params.recover = true;\n                  var seq = _this19._getLastSeq(channel);\n                  if (seq) {\n                    msg.params.seq = seq;\n                  }\n                  var gen = _this19._getLastGen(channel);\n                  if (gen) {\n                    msg.params.gen = gen;\n                  }\n                  var epoch = _this19._getLastEpoch(channel);\n                  if (epoch) {\n                    msg.params.epoch = epoch;\n                  }\n                }\n                _this19._call(msg).then(function (result) {\n                  _this19._subscribeResponse(channel, _this19._decoder.decodeCommandResult(_this19._methodType.SUBSCRIBE, result.result));\n                  if (result.next) {\n                    result.next();\n                  }\n                }, function (err) {\n                  _this19._subscribeError(channel, err);\n                });\n              }\n            }();\n\n            if (_ret2 === 'continue') continue;\n          }\n        }\n\n        if (batch) {\n          _this19.stopBatching();\n        }\n      };\n\n      if (this._config.onPrivateSubscribe !== null) {\n        this._config.onPrivateSubscribe({\n          data: data\n        }, cb);\n      } else {\n        var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n        this._xhrs[xhrID] = xhr;\n      }\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe(channel, events) {\n      var currentSub = this._getSub(channel);\n      if (currentSub !== null) {\n        currentSub._setEvents(events);\n        if (currentSub._isUnsubscribed()) {\n          currentSub.subscribe();\n        }\n        return currentSub;\n      }\n      var sub = new _subscription2.default(this, channel, events);\n      this._subs[channel] = sub;\n      sub.subscribe();\n      return sub;\n    }\n  }]);\n\n  return Centrifuge;\n}(_events2.default);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(6);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _utils = __webpack_require__(7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _STATE_NEW = 0;\nvar _STATE_SUBSCRIBING = 1;\nvar _STATE_SUCCESS = 2;\nvar _STATE_ERROR = 3;\nvar _STATE_UNSUBSCRIBED = 4;\n\nvar Subscription = function (_EventEmitter) {\n  _inherits(Subscription, _EventEmitter);\n\n  function Subscription(centrifuge, channel, events) {\n    _classCallCheck(this, Subscription);\n\n    var _this = _possibleConstructorReturn(this, (Subscription.__proto__ || Object.getPrototypeOf(Subscription)).call(this));\n\n    _this.channel = channel;\n    _this._centrifuge = centrifuge;\n    _this._status = _STATE_NEW;\n    _this._error = null;\n    _this._isResubscribe = false;\n    _this._ready = false;\n    _this._subscriptionPromise = null;\n    _this._noResubscribe = false;\n    _this._recoverable = false;\n    _this._recover = false;\n    _this._setEvents(events);\n    _this._initializePromise();\n    _this._promises = {};\n    _this.on('error', function (errContext) {\n      this._centrifuge._debug('subscription error', errContext);\n    });\n    return _this;\n  }\n\n  _createClass(Subscription, [{\n    key: '_initializePromise',\n    value: function _initializePromise() {\n      var _this2 = this;\n\n      // this helps us to wait until subscription will successfully\n      // subscribe and call actions such as presence, history etc in\n      // synchronous way.\n      this._ready = false;\n\n      this._subscriptionPromise = new Promise(function (resolve, reject) {\n        _this2._resolve = function (value) {\n          _this2._ready = true;\n          resolve(value);\n        };\n        _this2._reject = function (err) {\n          _this2._ready = true;\n          reject(err);\n        };\n      }).then(function () {}, function () {});\n    }\n  }, {\n    key: '_needRecover',\n    value: function _needRecover() {\n      return this._recoverable === true && this._recover === true;\n    }\n  }, {\n    key: '_setEvents',\n    value: function _setEvents(events) {\n      if (!events) {\n        return;\n      }\n      if ((0, _utils.isFunction)(events)) {\n        // events is just a function to handle publication received from channel.\n        this.on('publish', events);\n      } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n        var knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n        for (var i = 0, l = knownEvents.length; i < l; i++) {\n          var ev = knownEvents[i];\n          if (ev in events) {\n            this.on(ev, events[ev]);\n          }\n        }\n      }\n    }\n  }, {\n    key: '_isNew',\n    value: function _isNew() {\n      return this._status === _STATE_NEW;\n    }\n  }, {\n    key: '_isUnsubscribed',\n    value: function _isUnsubscribed() {\n      return this._status === _STATE_UNSUBSCRIBED;\n    }\n  }, {\n    key: '_isSubscribing',\n    value: function _isSubscribing() {\n      return this._status === _STATE_SUBSCRIBING;\n    }\n  }, {\n    key: '_isReady',\n    value: function _isReady() {\n      return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n    }\n  }, {\n    key: '_isSuccess',\n    value: function _isSuccess() {\n      return this._status === _STATE_SUCCESS;\n    }\n  }, {\n    key: '_isError',\n    value: function _isError() {\n      return this._status === _STATE_ERROR;\n    }\n  }, {\n    key: '_setNew',\n    value: function _setNew() {\n      this._status = _STATE_NEW;\n    }\n  }, {\n    key: '_setSubscribing',\n    value: function _setSubscribing(isResubscribe) {\n      this._isResubscribe = isResubscribe || false;\n      if (this._ready === true) {\n        // new promise for this subscription\n        this._initializePromise();\n      }\n      this._status = _STATE_SUBSCRIBING;\n    }\n  }, {\n    key: '_setSubscribeSuccess',\n    value: function _setSubscribeSuccess(recovered) {\n      if (this._status === _STATE_SUCCESS) {\n        return;\n      }\n      this._status = _STATE_SUCCESS;\n      var successContext = this._getSubscribeSuccessContext(recovered);\n\n      this._recover = false;\n      this.emit('subscribe', successContext);\n      this._resolve(successContext);\n      for (var to in this._promises) {\n        clearTimeout(to);\n        this._promises[to].resolve();\n        delete this._promises[to];\n      }\n    }\n  }, {\n    key: '_setSubscribeError',\n    value: function _setSubscribeError(err) {\n      if (this._status === _STATE_ERROR) {\n        return;\n      }\n      this._status = _STATE_ERROR;\n      this._error = err;\n      var errContext = this._getSubscribeErrorContext();\n      this.emit('error', errContext);\n      this._reject(errContext);\n      for (var to in this._promises) {\n        clearTimeout(to);\n        this._promises[to].reject(err);\n        delete this._promises[to];\n      }\n    }\n  }, {\n    key: '_triggerUnsubscribe',\n    value: function _triggerUnsubscribe() {\n      this.emit('unsubscribe', {\n        channel: this.channel\n      });\n    }\n  }, {\n    key: '_setUnsubscribed',\n    value: function _setUnsubscribed(noResubscribe) {\n      this._centrifuge._clearSubRefreshTimeout(this.channel);\n      if (this._status === _STATE_UNSUBSCRIBED) {\n        return;\n      }\n      var needTrigger = this._status === _STATE_SUCCESS;\n      this._status = _STATE_UNSUBSCRIBED;\n      if (noResubscribe === true) {\n        this._recover = false;\n        this._noResubscribe = true;\n        delete this._centrifuge._lastSeq[this.channel];\n        delete this._centrifuge._lastGen[this.channel];\n        delete this._centrifuge._lastEpoch[this.channel];\n      }\n      if (needTrigger) {\n        this._triggerUnsubscribe();\n      }\n    }\n  }, {\n    key: '_shouldResubscribe',\n    value: function _shouldResubscribe() {\n      return !this._noResubscribe;\n    }\n  }, {\n    key: '_getSubscribeSuccessContext',\n    value: function _getSubscribeSuccessContext(recovered) {\n      return {\n        channel: this.channel,\n        isResubscribe: this._isResubscribe,\n        recovered: recovered\n      };\n    }\n  }, {\n    key: '_getSubscribeErrorContext',\n    value: function _getSubscribeErrorContext() {\n      var subscribeErrorContext = this._error;\n      subscribeErrorContext.channel = this.channel;\n      subscribeErrorContext.isResubscribe = this._isResubscribe;\n      return subscribeErrorContext;\n    }\n  }, {\n    key: 'ready',\n    value: function ready(callback, errback) {\n      if (this._ready) {\n        if (this._isSuccess()) {\n          callback(this._getSubscribeSuccessContext());\n        } else {\n          errback(this._getSubscribeErrorContext());\n        }\n      }\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe() {\n      if (this._status === _STATE_SUCCESS) {\n        return;\n      }\n      this._noResubscribe = false;\n      this._centrifuge._subscribe(this);\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      this._setUnsubscribed(true);\n      this._centrifuge._unsubscribe(this);\n    }\n  }, {\n    key: '_methodCall',\n    value: function _methodCall(message, type) {\n      var _this3 = this;\n\n      var methodCallPromise = new Promise(function (resolve, reject) {\n        var subPromise = void 0;\n        if (_this3._isSuccess()) {\n          subPromise = Promise.resolve();\n        } else if (_this3._isError()) {\n          subPromise = Promise.reject(_this3._error);\n        } else {\n          subPromise = new Promise(function (res, rej) {\n            var timeout = setTimeout(function () {\n              rej({ 'code': 0, 'message': 'timeout' });\n            }, _this3._centrifuge._config.timeout);\n            _this3._promises[timeout] = {\n              resolve: res,\n              reject: rej\n            };\n          });\n        }\n        subPromise.then(function () {\n          return _this3._centrifuge._call(message).then(function (result) {\n            resolve(_this3._centrifuge._decoder.decodeCommandResult(type, result.result));\n            if (result.next) {\n              result.next();\n            }\n          }, function (error) {\n            reject(error);\n          });\n        }, function (error) {\n          reject(error);\n        });\n      });\n      return methodCallPromise;\n    }\n  }, {\n    key: 'publish',\n    value: function publish(data) {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PUBLISH,\n        params: {\n          channel: this.channel,\n          data: data\n        }\n      }, this._centrifuge._methodType.PUBLISH);\n    }\n  }, {\n    key: 'presence',\n    value: function presence() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PRESENCE,\n        params: {\n          channel: this.channel\n        }\n      }, this._centrifuge._methodType.PRESENCE);\n    }\n  }, {\n    key: 'presenceStats',\n    value: function presenceStats() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PRESENCE_STATS,\n        params: {\n          channel: this.channel\n        }\n      }, this._centrifuge._methodType.PRESENCE_STATS);\n    }\n  }, {\n    key: 'history',\n    value: function history() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.HISTORY,\n        params: {\n          channel: this.channel\n        }\n      }, this._centrifuge._methodType.HISTORY);\n    }\n  }]);\n\n  return Subscription;\n}(_events2.default);\n\nexports.default = Subscription;\nmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 12:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JsonMethodType = exports.JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10,\n  SUB_REFRESH: 11\n};\n\nvar JsonPushType = exports.JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4\n};\n\nvar JsonEncoder = exports.JsonEncoder = function () {\n  function JsonEncoder() {\n    _classCallCheck(this, JsonEncoder);\n  }\n\n  _createClass(JsonEncoder, [{\n    key: 'encodeCommands',\n    value: function encodeCommands(commands) {\n      var encodedCommands = [];\n      for (var i in commands) {\n        if (commands.hasOwnProperty(i)) {\n          encodedCommands.push(JSON.stringify(commands[i]));\n        }\n      }\n      return encodedCommands.join('\\n');\n    }\n  }]);\n\n  return JsonEncoder;\n}();\n\nvar JsonDecoder = exports.JsonDecoder = function () {\n  function JsonDecoder() {\n    _classCallCheck(this, JsonDecoder);\n  }\n\n  _createClass(JsonDecoder, [{\n    key: 'decodeReplies',\n    value: function decodeReplies(data) {\n      var replies = [];\n      var encodedReplies = data.split('\\n');\n      for (var i in encodedReplies) {\n        if (encodedReplies.hasOwnProperty(i)) {\n          if (!encodedReplies[i]) {\n            continue;\n          }\n          var reply = JSON.parse(encodedReplies[i]);\n          replies.push(reply);\n        }\n      }\n      return replies;\n    }\n  }, {\n    key: 'decodeCommandResult',\n    value: function decodeCommandResult(methodType, data) {\n      return data;\n    }\n  }, {\n    key: 'decodePush',\n    value: function decodePush(data) {\n      return data;\n    }\n  }, {\n    key: 'decodePushData',\n    value: function decodePushData(pushType, data) {\n      return data;\n    }\n  }]);\n\n  return JsonDecoder;\n}();\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n\n/***/ 31:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _centrifuge = __webpack_require__(10);\n\nexports.default = _centrifuge.Centrifuge;\nmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n/***/ }),\n\n/***/ 7:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startsWith = startsWith;\nexports.isFunction = isFunction;\nexports.log = log;\nexports.backoff = backoff;\nexports.errorExists = errorExists;\nfunction startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nfunction isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nfunction log(level, args) {\n  if (global.console) {\n    var logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nfunction backoff(step, min, max) {\n  var jitter = 0.5 * Math.random();\n  var interval = Math.min(max, min * Math.pow(2, step + 1));\n\n  return Math.floor((1 - jitter) * interval);\n};\n\nfunction errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// centrifuge.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 31);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6b3b6ab76ba6fd6b7ca2","import EventEmitter from 'events';\nimport Subscription from './subscription';\n\nimport {\n  JsonEncoder,\n  JsonDecoder,\n  JsonMethodType,\n  JsonPushType\n} from './json';\n\nimport {\n  isFunction,\n  log,\n  startsWith,\n  errorExists,\n  backoff\n} from './utils';\n\nconst _errorTimeout = 'timeout';\nconst _errorConnectionClosed = 'connection closed';\n\nexport class Centrifuge extends EventEmitter {\n\n  constructor(url, options) {\n    super();\n    this._url = url;\n    this._sockjs = null;\n    this._isSockjs = false;\n    this._binary = false;\n    this._methodType = null;\n    this._pushType = null;\n    this._encoder = null;\n    this._decoder = null;\n    this._status = 'disconnected';\n    this._reconnect = true;\n    this._reconnecting = false;\n    this._transport = null;\n    this._transportName = null;\n    this._transportClosed = true;\n    this._messageId = 0;\n    this._clientID = null;\n    this._refreshRequired = false;\n    this._subs = {};\n    this._lastSeq = {};\n    this._lastGen = {};\n    this._lastEpoch = {};\n    this._messages = [];\n    this._isBatching = false;\n    this._isSubscribeBatching = false;\n    this._privateChannels = {};\n    this._numRefreshFailed = 0;\n    this._refreshTimeout = null;\n    this._pingTimeout = null;\n    this._pongTimeout = null;\n    this._subRefreshTimeouts = {};\n    this._retries = 0;\n    this._callbacks = {};\n    this._latency = null;\n    this._latencyStart = null;\n    this._connectData = null;\n    this._token = null;\n    this._xhrID = 0;\n    this._xhrs = {};\n    this._config = {\n      debug: false,\n      sockjs: null,\n      promise: null,\n      minRetry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      ping: true,\n      pingInterval: 25000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: [\n        'websocket',\n        'xdr-streaming',\n        'xhr-streaming',\n        'eventsource',\n        'iframe-eventsource',\n        'iframe-htmlfile',\n        'xdr-polling',\n        'xhr-polling',\n        'iframe-xhr-polling',\n        'jsonp-polling'\n      ],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 1000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      subscribeEndpoint: '/centrifuge/subscribe',\n      subscribeHeaders: {},\n      subscribeParams: {},\n      subRefreshInterval: 1000,\n      onPrivateSubscribe: null\n    };\n    this._configure(options);\n  }\n\n  setToken(token) {\n    this._token = token;\n  }\n\n  setConnectData(data) {\n    this._connectData = data;\n  }\n\n  _ajax(url, params, headers, data, callback) {\n    let query = '';\n    this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n    const xhr = (global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP'));\n\n    for (const i in params) {\n      if (params.hasOwnProperty(i)) {\n        if (query.length > 0) {\n          query += '&';\n        }\n        query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n      }\n    }\n    if (query.length > 0) {\n      query = '?' + query;\n    }\n    xhr.open('POST', url + query, true);\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    for (const headerName in headers) {\n      if (headers.hasOwnProperty(headerName)) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          let data, parsed = false;\n          try {\n            data = JSON.parse(xhr.responseText);\n            parsed = true;\n          } catch (e) {\n            callback({\n              error: 'Invalid JSON. Data was: ' + xhr.responseText,\n              status: 200,\n              data: null\n            });\n          }\n          if (parsed) { // prevents double execution.\n            callback({\n              data: data,\n              status: 200\n            });\n          }\n        } else {\n          this._log('wrong status code in AJAX response', xhr.status);\n          callback({\n            status: xhr.status,\n            data: null\n          });\n        }\n      }\n    };\n    setTimeout(() => xhr.send(JSON.stringify(data)), 20);\n    return xhr;\n  };\n\n  _log() {\n    log('info', arguments);\n  };\n\n  _debug() {\n    if (this._config.debug === true) {\n      log('debug', arguments);\n    }\n  };\n\n  _websocketSupported() {\n    return !(typeof WebSocket !== 'function' && typeof WebSocket !== 'object');\n  };\n\n  _setFormat(format) {\n    if (this._formatOverride(format)) {\n      return;\n    }\n    if (format === 'protobuf') {\n      throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n    }\n    this._binary = false;\n    this._methodType = JsonMethodType;\n    this._pushType = JsonPushType;\n    this._encoder = new JsonEncoder();\n    this._decoder = new JsonDecoder();\n  }\n\n  _formatOverride(format) {\n    return false;\n  }\n\n  _configure(configuration) {\n    if (!('Promise' in global)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    Object.assign(this._config, configuration || {});\n    this._debug('centrifuge config', this._config);\n\n    if (!this._url) {\n      throw new Error('url required');\n    }\n\n    if (startsWith(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n      this._setFormat('protobuf');\n    } else {\n      this._setFormat('json');\n    }\n\n    if (startsWith(this._url, 'http')) {\n      this._debug('client will try to connect to SockJS endpoint');\n      if (this._config.sockjs !== null) {\n        this._debug('SockJS explicitly provided in options');\n        this._sockjs = this._config.sockjs;\n      } else {\n        if (typeof global.SockJS === 'undefined') {\n          throw new Error('SockJS not found, use ws:// in url or include SockJS');\n        }\n        this._debug('use globally defined SockJS');\n        this._sockjs = global.SockJS;\n      }\n    } else {\n      this._debug('client will connect to websocket endpoint');\n    }\n  };\n\n  _setStatus(newStatus) {\n    if (this._status !== newStatus) {\n      this._debug('Status', this._status, '->', newStatus);\n      this._status = newStatus;\n    }\n  };\n\n  _isDisconnected() {\n    return this._status === 'disconnected';\n  };\n\n  _isConnecting() {\n    return this._status === 'connecting';\n  };\n\n  _isConnected() {\n    return this._status === 'connected';\n  };\n\n  _nextMessageId() {\n    return ++this._messageId;\n  };\n\n  _resetRetry() {\n    this._debug('reset retries count to 0');\n    this._retries = 0;\n  };\n\n  _getRetryInterval() {\n    const interval = backoff(this._retries, this._config.minRetry, this._config.maxRetry);\n\n    this._retries += 1;\n    return interval;\n  };\n\n  _abortInflightXHRs() {\n    for (const xhrID in this._xhrs) {\n      try {\n        this._xhrs[xhrID].abort();\n      } catch (e) {\n        this._debug('error aborting xhr', e);\n      }\n      delete this._xhrs[xhrID];\n    }\n  };\n\n  _clearConnectedState(reconnect) {\n    this._clientID = null;\n    this._stopPing();\n\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback(this._createErrorObject('disconnected'));\n      }\n    }\n    this._callbacks = {};\n\n    // fire unsubscribe events\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n\n        if (reconnect) {\n          if (sub._isSuccess()) {\n            sub._triggerUnsubscribe();\n            sub._recover = true;\n          }\n          sub._setSubscribing();\n        } else {\n          sub._setUnsubscribed();\n        }\n      }\n    }\n\n    this._abortInflightXHRs();\n\n    // clear refresh timer\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    // clear sub refresh timers\n    for (const channel in this._subRefreshTimeouts) {\n      if (this._subRefreshTimeouts.hasOwnProperty(channel) && this._subRefreshTimeouts[channel]) {\n        this._clearSubRefreshTimeout(channel);\n      }\n    }\n    this._subRefreshTimeouts = {};\n\n    if (!this._reconnect) {\n      // completely clear subscriptions\n      this._subs = {};\n    }\n  };\n\n  _isTransportOpen() {\n    if (this._isSockjs) {\n      return this._transport &&\n        this._transport.transport &&\n        this._transport.transport.readyState === this._transport.transport.OPEN;\n    }\n    return this._transport && this._transport.readyState === this._transport.OPEN;\n  };\n\n  _transportSend(commands) {\n    if (!commands.length) {\n      return true;\n    }\n\n    if (!this._isTransportOpen()) {\n      // resolve pending commands with error if transport is not open\n      for (let command in commands) {\n        let id = command.id;\n        if (!(id in this._callbacks)) {\n          continue;\n        }\n        const callbacks = this._callbacks[id];\n        clearTimeout(this._callbacks[id].timeout);\n        delete this._callbacks[id];\n        const errback = callbacks.errback;\n        errback(this._createErrorObject(_errorConnectionClosed, 0));\n      }\n      return false;\n    }\n    this._transport.send(this._encoder.encodeCommands(commands));\n    return true;\n  }\n\n  _setupTransport() {\n    this._isSockjs = false;\n\n    // detect transport to use - SockJS or Websocket\n    if (this._sockjs !== null) {\n      const sockjsOptions = {\n        transports: this._config.sockjsTransports\n      };\n\n      if (this._config.sockjsServer !== null) {\n        sockjsOptions.server = this._config.sockjsServer;\n      }\n      this._isSockjs = true;\n      this._transport = new this._sockjs(this._url, null, sockjsOptions);\n    } else {\n      if (!this._websocketSupported()) {\n        this._debug('No Websocket support and no SockJS configured, can not connect');\n        return;\n      }\n      this._transport = new WebSocket(this._url);\n      if (this._binary === true) {\n        this._transport.binaryType = 'arraybuffer';\n      }\n    }\n\n    this._transport.onopen = () => {\n      this._transportClosed = false;\n\n      if (this._isSockjs) {\n        this._transportName = 'sockjs-' + this._transport.transport;\n        this._transport.onheartbeat = () => this._restartPing();\n      } else {\n        this._transportName = 'websocket';\n      }\n\n      // Can omit method here due to zero value.\n      const msg = {\n        // method: this._methodType.CONNECT\n      };\n\n      if (this._token || this._connectData) {\n        msg.params = {};\n      }\n\n      if (this._token) {\n        msg.params.token = this._token;\n      }\n\n      if (this._connectData) {\n        msg.params.data = this._connectData;\n      }\n\n      this._latencyStart = new Date();\n      this._call(msg).then(result => {\n        this._connectResponse(this._decoder.decodeCommandResult(this._methodType.CONNECT, result.result));\n        if (result.next) {\n          result.next();\n        }\n      }, err => {\n        if (err.code === 109) { // token expired.\n          this._refreshRequired = true;\n        }\n        this._disconnect('connect error', true);\n      });\n    };\n\n    this._transport.onerror = error => {\n      this._debug('transport level error', error);\n    };\n\n    this._transport.onclose = closeEvent => {\n      this._transportClosed = true;\n      let reason = _errorConnectionClosed;\n      let needReconnect = true;\n\n      if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n        try {\n          const advice = JSON.parse(closeEvent.reason);\n          this._debug('reason is an advice object', advice);\n          reason = advice.reason;\n          needReconnect = advice.reconnect;\n        } catch (e) {\n          reason = closeEvent.reason;\n          this._debug('reason is a plain string', reason);\n        }\n      }\n\n      // onTransportClose callback should be executed every time transport was closed.\n      // This can be helpful to catch failed connection events (because our disconnect\n      // event only called once and every future attempts to connect do not fire disconnect\n      // event again).\n      if (this._config.onTransportClose !== null) {\n        this._config.onTransportClose({\n          event: closeEvent,\n          reason: reason,\n          reconnect: needReconnect\n        });\n      }\n\n      this._disconnect(reason, needReconnect);\n\n      if (this._reconnect === true) {\n        this._reconnecting = true;\n        const interval = this._getRetryInterval();\n\n        this._debug('reconnect after ' + interval + ' milliseconds');\n        setTimeout(() => {\n          if (this._reconnect === true) {\n            if (this._refreshRequired) {\n              this._refresh();\n            } else {\n              this._connect();\n            }\n          }\n        }, interval);\n      }\n    };\n\n    this._transport.onmessage = event => {\n      this._dataReceived(event.data);\n    };\n  };\n\n  rpc(data) {\n    const msg = {\n      method: this._methodType.RPC,\n      params: {\n        data: data\n      }\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    return this._call(msg).then(result => {\n      if (result.next) {\n        result.next();\n      }\n      return this._decoder.decodeCommandResult(this._methodType.RPC, result.result);\n    });\n  }\n\n  send(data) {\n    const msg = {\n      method: this._methodType.SEND,\n      params: {\n        data: data\n      }\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    const sent = this._transportSend([msg]); // can send async message to server without id set\n    if (!sent) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    };\n    return Promise.resolve({});\n  }\n\n  publish(channel, data) {\n    const msg = {\n      method: this._methodType.PUBLISH,\n      params: {\n        channel: channel,\n        data: data\n      }\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    return this._call(msg).then(result => {\n      if (result.next) {\n        result.next();\n      }\n      return {};\n    });\n  }\n\n  _dataReceived(data) {\n    const replies = this._decoder.decodeReplies(data);\n    // we have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    let p = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    this._restartPing();\n  }\n\n  _call(msg) {\n    return new Promise((resolve, reject) => {\n      const id = this._addMessage(msg);\n      this._registerCall(id, resolve, reject);\n    });\n  }\n\n  _connect() {\n    if (this.isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._status === 'connecting') {\n      return;\n    }\n\n    this._debug('start connecting');\n    this._setStatus('connecting');\n    this._clientID = null;\n    this._reconnect = true;\n    this._setupTransport();\n  };\n\n  _disconnect(reason, shouldReconnect) {\n\n    if (this._isDisconnected()) {\n      return;\n    }\n\n    this._debug('disconnected:', reason, shouldReconnect);\n\n    const reconnect = shouldReconnect || false;\n\n    if (reconnect === false) {\n      this._reconnect = false;\n    }\n\n    this._clearConnectedState(reconnect);\n\n    if (!this._isDisconnected()) {\n      this._setStatus('disconnected');\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n        this._refreshTimeout = null;\n      }\n      if (this._reconnecting === false) {\n        this.emit('disconnect', {\n          reason: reason,\n          reconnect: reconnect\n        });\n      }\n    }\n\n    if (!this._transportClosed) {\n      this._transport.close();\n    }\n  };\n\n  _refreshFailed() {\n    this._numRefreshFailed = 0;\n    if (!this._isDisconnected()) {\n      this._disconnect('refresh failed', false);\n    }\n    if (this._config.onRefreshFailed !== null) {\n      this._config.onRefreshFailed();\n    }\n  };\n\n  _refresh() {\n    // ask application for new connection token.\n    this._debug('refresh token');\n\n    if (this._config.refreshAttempts === 0) {\n      this._debug('refresh attempts set to 0, do not send refresh request at all');\n      this._refreshFailed();\n      return;\n    }\n\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        // We don't perform any connection status related actions here as we are\n        // relying on server that must close connection eventually.\n        if (resp.error) {\n          this._debug('error refreshing connection token', resp.error);\n        } else {\n          this._debug('error refreshing connection token: wrong status code', resp.status);\n        }\n        this._numRefreshFailed++;\n        if (this._refreshTimeout !== null) {\n          clearTimeout(this._refreshTimeout);\n          this._refreshTimeout = null;\n        }\n        if (this._config.refreshAttempts !== null && this._numRefreshFailed >= this._config.refreshAttempts) {\n          this._refreshFailed();\n          return;\n        }\n        const jitter = Math.round(Math.random() * 1000 * Math.max(this._numRefreshFailed, 20));\n        const interval = this._config.refreshInterval + jitter;\n        this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n        return;\n      }\n      this._numRefreshFailed = 0;\n      this._token = resp.data.token;\n      if (!this._token) {\n        this._refreshFailed();\n        return;\n      }\n      if (this._isDisconnected() && this._reconnect) {\n        this._debug('token refreshed, connect from scratch');\n        this._connect();\n      } else {\n        this._debug('send refreshed token');\n        const msg = {\n          method: this._methodType.REFRESH,\n          params: {\n            token: this._token\n          }\n        };\n        this._call(msg).then(result => {\n          this._refreshResponse(this._decoder.decodeCommandResult(this._methodType.REFRESH, result.result));\n          if (result.next) {\n            result.next();\n          }\n        }, err => {\n          this._refreshError(err);\n        });\n      }\n    };\n\n    if (this._config.onRefresh !== null) {\n      const context = {};\n      this._config.onRefresh(context, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.refreshEndpoint,\n        this._config.refreshParams,\n        this._config.refreshHeaders,\n        this._config.refreshData,\n        cb\n      );\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _refreshError(err) {\n    this._debug('refresh error', err);\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    const interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n    this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n  }\n\n  _refreshResponse(result) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._clientID = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n  };\n\n  _newXHRID() {\n    this._xhrID++;\n    return this._xhrID;\n  }\n\n  _subRefresh(channel) {\n    this._debug('refresh subscription token for channel', channel);\n\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      this._clearSubRefreshTimeout(channel);\n    } else {\n      return;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (resp.error || resp.status !== 200 || this._clientID !== clientID) {\n        return;\n      }\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      const token = channelsData[channel];\n      if (!token) {\n        return;\n      }\n      const msg = {\n        method: this._methodType.SUB_REFRESH,\n        params: {\n          channel: channel,\n          token: token\n        }\n      };\n\n      const sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n\n      this._call(msg).then(result => {\n        this._subRefreshResponse(\n          channel,\n          this._decoder.decodeCommandResult(this._methodType.SUB_REFRESH, result.result)\n        );\n        if (result.next) {\n          result.next();\n        }\n      }, err => {\n        this._subRefreshError(channel, err);\n      });\n    };\n\n    const data = {\n      client: this._clientID,\n      channels: [channel]\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _clearSubRefreshTimeout(channel) {\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      clearTimeout(this._subRefreshTimeouts[channel]);\n      delete this._subRefreshTimeouts[channel];\n    }\n  }\n\n  _subRefreshError(channel, err) {\n    this._debug('subscription refresh error', channel, err);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    const jitter = Math.round(Math.random() * 1000);\n    let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._config.subRefreshInterval + jitter);\n    this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    return;\n  }\n\n  _subRefreshResponse(channel, result) {\n    this._debug('subscription refresh success', channel);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n    return;\n  };\n\n  _subscribe(sub, isResubscribe) {\n    this._debug('subscribing on', sub.channel);\n    const channel = sub.channel;\n\n    if (!(channel in this._subs)) {\n      this._subs[channel] = sub;\n    }\n\n    if (!this.isConnected()) {\n      // subscribe will be called later\n      sub._setNew();\n      return;\n    }\n\n    sub._setSubscribing(isResubscribe);\n\n    const msg = {\n      method: this._methodType.SUBSCRIBE,\n      params: {\n        channel: channel\n      }\n    };\n\n    // If channel name does not start with privateChannelPrefix - then we\n    // can just send subscription message to Centrifuge. If channel name\n    // starts with privateChannelPrefix - then this is a private channel\n    // and we should ask web application backend for permission first.\n    if (startsWith(channel, this._config.privateChannelPrefix)) {\n      // private channel.\n      if (this._isSubscribeBatching) {\n        this._privateChannels[channel] = true;\n      } else {\n        this.startSubscribeBatching();\n        this._subscribe(sub);\n        this.stopSubscribeBatching();\n      }\n    } else {\n      const recover = sub._needRecover();\n\n      if (recover === true) {\n        msg.params.recover = true;\n        const seq = this._getLastSeq(channel);\n        if (seq) {\n          msg.params.seq = seq;\n        }\n        const gen = this._getLastGen(channel);\n        if (gen) {\n          msg.params.gen = gen;\n        }\n        const epoch = this._getLastEpoch(channel);\n        if (epoch) {\n          msg.params.epoch = epoch;\n        }\n      }\n\n      this._call(msg).then(result => {\n        this._subscribeResponse(channel, this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, result.result));\n        if (result.next) {\n          result.next();\n        }\n      }, err => {\n        this._subscribeError(channel, err);\n      });\n    }\n  };\n\n  _unsubscribe(sub) {\n    if (this.isConnected()) {\n      // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n      this._addMessage({\n        method: this._methodType.UNSUBSCRIBE,\n        params: {\n          channel: sub.channel\n        }\n      });\n    }\n  };\n\n  _getTTLMilliseconds(ttl) {\n    // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n    return Math.min(ttl * 1000, 2147483647);\n  }\n\n  getSub(channel) {\n    return this._getSub(channel);\n  }\n\n  _getSub(channel) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  };\n\n  _connectResponse(result) {\n    const wasReconnecting = this._reconnecting;\n    this._reconnecting = false;\n    this._resetRetry();\n    this._refreshRequired = false;\n\n    if (this.isConnected()) {\n      return;\n    }\n\n    if (this._latencyStart !== null) {\n      this._latency = (new Date()).getTime() - this._latencyStart.getTime();\n      this._latencyStart = null;\n    }\n\n    this._clientID = result.client;\n    this._setStatus('connected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n\n    this.startBatching();\n    this.startSubscribeBatching();\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n        if (sub._shouldResubscribe()) {\n          this._subscribe(sub, wasReconnecting);\n        }\n      }\n    }\n    this.stopSubscribeBatching();\n    this.stopBatching();\n\n    this._startPing();\n\n    const ctx = {\n      client: result.client,\n      transport: this._transportName,\n      latency: this._latency\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connect', ctx);\n  };\n\n  _stopPing() {\n    if (this._pongTimeout !== null) {\n      clearTimeout(this._pongTimeout);\n      this._pongTimeout = null;\n    }\n    if (this._pingTimeout !== null) {\n      clearTimeout(this._pingTimeout);\n      this._pingTimeout = null;\n    }\n  };\n\n  _startPing() {\n    if (this._config.ping !== true || this._config.pingInterval <= 0) {\n      return;\n    }\n    if (!this.isConnected()) {\n      return;\n    }\n\n    this._pingTimeout = setTimeout(() => {\n      if (!this.isConnected()) {\n        this._stopPing();\n        return;\n      }\n      this.ping();\n      this._pongTimeout = setTimeout(() => {\n        this._disconnect('no ping', true);\n      }, this._config.pongWaitTimeout);\n    }, this._config.pingInterval);\n  };\n\n  _restartPing() {\n    this._stopPing();\n    this._startPing();\n  };\n\n  _subscribeError(channel, error) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    if (error.code === 0 && error.message === _errorTimeout) { // client side timeout.\n      this._disconnect('timeout', true);\n      return;\n    }\n    sub._setSubscribeError(error);\n  };\n\n  _subscribeResponse(channel, result) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n\n    let recovered = false;\n    if ('recovered' in result) {\n      recovered = result.recovered;\n    }\n    sub._setSubscribeSuccess(recovered);\n\n    let pubs = result.publications;\n\n    if (pubs && pubs.length > 0) {\n      // handle missed pubs.\n      pubs = pubs.reverse();\n      for (let i in pubs) {\n        if (pubs.hasOwnProperty(i)) {\n          this._handlePublication(channel, pubs[i]);\n        }\n      }\n    } else {\n      if (result.recoverable) {\n        this._lastSeq[channel] = result.seq || 0;\n        this._lastGen[channel] = result.gen || 0;\n      }\n    }\n\n    this._lastEpoch[channel] = result.epoch || '';\n\n    if (result.recoverable) {\n      sub._recoverable = true;\n    }\n\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n  };\n\n  _handleReply(reply, next) {\n    const id = reply.id;\n    const result = reply.result;\n\n    if (!(id in this._callbacks)) {\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({result, next});\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        return;\n      }\n      errback(reply.error);\n    }\n  }\n\n  _handleJoin(channel, join) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    sub.emit('join', join);\n  };\n\n  _handleLeave(channel, leave) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    sub.emit('leave', leave);\n  };\n\n  _handleUnsub(channel, unsub) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    sub.unsubscribe();\n    if (unsub.resubscribe === true) {\n      sub.subscribe();\n    }\n  };\n\n  _handlePublication(channel, pub) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (pub.seq !== undefined) {\n      this._lastSeq[channel] = pub.seq;\n    }\n    if (pub.gen !== undefined) {\n      this._lastGen[channel] = pub.gen;\n    }\n    sub.emit('publish', pub);\n  };\n\n  _handleMessage(message) {\n    this.emit('message', message.data);\n  };\n\n  _handlePush(data, next) {\n    const push = this._decoder.decodePush(data);\n    let type = 0;\n    if ('type' in push) {\n      type = push['type'];\n    }\n    const channel = push.channel;\n\n    if (type === this._pushType.PUBLICATION) {\n      const pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n      this._handlePublication(channel, pub);\n    } else if (type === this._pushType.MESSAGE) {\n      const message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n      this._handleMessage(message);\n    } else if (type === this._pushType.JOIN) {\n      const join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n      this._handleJoin(channel, join);\n    } else if (type === this._pushType.LEAVE) {\n      const leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n      this._handleLeave(channel, leave);\n    } else if (type === this._pushType.UNSUB) {\n      const unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n      this._handleUnsub(channel, unsub);\n    }\n    next();\n  }\n\n  _dispatchReply(reply) {\n    var next;\n    const p = new Promise(resolve =>{\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      this._handlePush(reply.result, next);\n    }\n\n    return p;\n  };\n\n  _flush() {\n    const messages = this._messages.slice(0);\n    this._messages = [];\n    this._transportSend(messages);\n  };\n\n  _ping() {\n    const msg = {\n      method: this._methodType.PING\n    };\n    this._call(msg).then(result => {\n      this._pingResponse(this._decoder.decodeCommandResult(this._methodType.PING, result.result));\n      result.next();\n    }, err => {\n      this._debug('ping error', err);\n    });\n  };\n\n  _pingResponse(result) {\n    if (!this.isConnected()) {\n      return;\n    }\n    this._stopPing();\n    this._startPing();\n  }\n\n  _getLastSeq(channel) {\n    const lastSeq = this._lastSeq[channel];\n    if (lastSeq) {\n      return lastSeq;\n    }\n    return 0;\n  };\n\n  _getLastGen(channel) {\n    const lastGen = this._lastGen[channel];\n    if (lastGen) {\n      return lastGen;\n    }\n    return 0;\n  };\n\n  _getLastEpoch(channel) {\n    const lastEpoch = this._lastEpoch[channel];\n    if (lastEpoch) {\n      return lastEpoch;\n    }\n    return '';\n  };\n\n  _createErrorObject(message, code) {\n    const errObject = {\n      message: message,\n      code: code || 0\n    };\n\n    return errObject;\n  };\n\n  _registerCall(id, callback, errback) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback(this._createErrorObject(_errorTimeout));\n      }\n    }, this._config.timeout);\n  };\n\n  _addMessage(message) {\n    let id = this._nextMessageId();\n    message.id = id;\n    if (this._isBatching === true) {\n      this._messages.push(message);\n    } else {\n      this._transportSend([message]);\n    }\n    return id;\n  };\n\n  isConnected() {\n    return this._isConnected();\n  }\n\n  connect() {\n    this._connect();\n  };\n\n  disconnect() {\n    this._disconnect('client', false);\n  };\n\n  ping() {\n    return this._ping();\n  }\n\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._isBatching = true;\n  };\n\n  stopBatching() {\n    this._isBatching = false;\n    this._flush();\n  };\n\n  startSubscribeBatching() {\n    // start collecting private channels to create bulk authentication\n    // request to subscribeEndpoint when stopSubscribeBatching will be called\n    this._isSubscribeBatching = true;\n  };\n\n  stopSubscribeBatching() {\n    // create request to subscribeEndpoint with collected private channels\n    // to ask if this client can subscribe on each channel\n    this._isSubscribeBatching = false;\n    const authChannels = this._privateChannels;\n    this._privateChannels = {};\n\n    const channels = [];\n\n    for (const channel in authChannels) {\n      if (authChannels.hasOwnProperty(channel)) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n          continue;\n        }\n        channels.push(channel);\n      }\n    }\n\n    if (channels.length === 0) {\n      this._debug('no private channels found, no need to make request');\n      return;\n    }\n\n    const data = {\n      client: this._clientID,\n      channels: channels\n    };\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        this._debug('authorization request failed');\n        for (const i in channels) {\n          if (channels.hasOwnProperty(i)) {\n            const channel = channels[i];\n            this._subscribeError(channel, this._createErrorObject('authorization request failed'));\n          }\n        }\n        return;\n      }\n\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      // try to send all subscriptions in one request.\n      let batch = false;\n\n      if (!this._isBatching) {\n        this.startBatching();\n        batch = true;\n      }\n\n      for (const i in channels) {\n        if (channels.hasOwnProperty(i)) {\n          const channel = channels[i];\n          const token = channelsData[channel];\n\n          if (!token) {\n            // subscription:error\n            this._subscribeError(channel, this._createErrorObject('permission denied', 103));\n            continue;\n          } else {\n            const msg = {\n              method: this._methodType.SUBSCRIBE,\n              params: {\n                channel: channel,\n                token: token\n              }\n            };\n\n            const sub = this._getSub(channel);\n            if (sub === null) {\n              continue;\n            }\n\n            const recover = sub._needRecover();\n\n            if (recover === true) {\n              msg.params.recover = true;\n              const seq = this._getLastSeq(channel);\n              if (seq) {\n                msg.params.seq = seq;\n              }\n              const gen = this._getLastGen(channel);\n              if (gen) {\n                msg.params.gen = gen;\n              }\n              const epoch = this._getLastEpoch(channel);\n              if (epoch) {\n                msg.params.epoch = epoch;\n              }\n            }\n            this._call(msg).then(result => {\n              this._subscribeResponse(\n                channel,\n                this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, result.result)\n              );\n              if (result.next) {\n                result.next();\n              }\n            }, err => {\n              this._subscribeError(channel, err);\n            });\n          }\n        }\n      }\n\n      if (batch) {\n        this.stopBatching();\n      }\n\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  subscribe(channel, events) {\n    const currentSub = this._getSub(channel);\n    if (currentSub !== null) {\n      currentSub._setEvents(events);\n      if (currentSub._isUnsubscribed()) {\n        currentSub.subscribe();\n      }\n      return currentSub;\n    }\n    const sub = new Subscription(this, channel, events);\n    this._subs[channel] = sub;\n    sub.subscribe();\n    return sub;\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/centrifuge.js","import EventEmitter from 'events';\n\nimport {\n  isFunction\n} from './utils';\n\nconst _STATE_NEW = 0;\nconst _STATE_SUBSCRIBING = 1;\nconst _STATE_SUCCESS = 2;\nconst _STATE_ERROR = 3;\nconst _STATE_UNSUBSCRIBED = 4;\n\nexport default class Subscription extends EventEmitter {\n  constructor(centrifuge, channel, events) {\n    super();\n    this.channel = channel;\n    this._centrifuge = centrifuge;\n    this._status = _STATE_NEW;\n    this._error = null;\n    this._isResubscribe = false;\n    this._ready = false;\n    this._subscriptionPromise = null;\n    this._noResubscribe = false;\n    this._recoverable = false;\n    this._recover = false;\n    this._setEvents(events);\n    this._initializePromise();\n    this._promises = {};\n    this.on('error', function (errContext) {\n      this._centrifuge._debug('subscription error', errContext);\n    });\n  }\n\n  _initializePromise() {\n    // this helps us to wait until subscription will successfully\n    // subscribe and call actions such as presence, history etc in\n    // synchronous way.\n    this._ready = false;\n\n    this._subscriptionPromise = new Promise((resolve, reject) => {\n      this._resolve = value => {\n        this._ready = true;\n        resolve(value);\n      };\n      this._reject = err => {\n        this._ready = true;\n        reject(err);\n      };\n    }).then(function () {}, function () {});\n  };\n\n  _needRecover() {\n    return this._recoverable === true && this._recover === true;\n  };\n\n  _setEvents(events) {\n    if (!events) {\n      return;\n    }\n    if (isFunction(events)) {\n      // events is just a function to handle publication received from channel.\n      this.on('publish', events);\n    } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n      const knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n      for (let i = 0, l = knownEvents.length; i < l; i++) {\n        const ev = knownEvents[i];\n        if (ev in events) {\n          this.on(ev, events[ev]);\n        }\n      }\n    }\n  };\n\n  _isNew() {\n    return this._status === _STATE_NEW;\n  };\n\n  _isUnsubscribed() {\n    return this._status === _STATE_UNSUBSCRIBED;\n  };\n\n  _isSubscribing() {\n    return this._status === _STATE_SUBSCRIBING;\n  };\n\n  _isReady() {\n    return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n  };\n\n  _isSuccess() {\n    return this._status === _STATE_SUCCESS;\n  };\n\n  _isError() {\n    return this._status === _STATE_ERROR;\n  };\n\n  _setNew() {\n    this._status = _STATE_NEW;\n  };\n\n  _setSubscribing(isResubscribe) {\n    this._isResubscribe = isResubscribe || false;\n    if (this._ready === true) {\n      // new promise for this subscription\n      this._initializePromise();\n    }\n    this._status = _STATE_SUBSCRIBING;\n  };\n\n  _setSubscribeSuccess(recovered) {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._status = _STATE_SUCCESS;\n    const successContext = this._getSubscribeSuccessContext(recovered);\n\n    this._recover = false;\n    this.emit('subscribe', successContext);\n    this._resolve(successContext);\n    for (const to in this._promises) {\n      clearTimeout(to);\n      this._promises[to].resolve();\n      delete this._promises[to];\n    }\n  };\n\n  _setSubscribeError(err) {\n    if (this._status === _STATE_ERROR) {\n      return;\n    }\n    this._status = _STATE_ERROR;\n    this._error = err;\n    const errContext = this._getSubscribeErrorContext();\n    this.emit('error', errContext);\n    this._reject(errContext);\n    for (const to in this._promises) {\n      clearTimeout(to);\n      this._promises[to].reject(err);\n      delete this._promises[to];\n    }\n  };\n\n  _triggerUnsubscribe() {\n    this.emit('unsubscribe', {\n      channel: this.channel\n    });\n  };\n\n  _setUnsubscribed(noResubscribe) {\n    this._centrifuge._clearSubRefreshTimeout(this.channel);\n    if (this._status === _STATE_UNSUBSCRIBED) {\n      return;\n    }\n    const needTrigger = this._status === _STATE_SUCCESS;\n    this._status = _STATE_UNSUBSCRIBED;\n    if (noResubscribe === true) {\n      this._recover = false;\n      this._noResubscribe = true;\n      delete this._centrifuge._lastSeq[this.channel];\n      delete this._centrifuge._lastGen[this.channel];\n      delete this._centrifuge._lastEpoch[this.channel];\n    }\n    if (needTrigger) {\n      this._triggerUnsubscribe();\n    }\n  };\n\n  _shouldResubscribe() {\n    return !this._noResubscribe;\n  };\n\n  _getSubscribeSuccessContext(recovered) {\n    return {\n      channel: this.channel,\n      isResubscribe: this._isResubscribe,\n      recovered: recovered\n    };\n  };\n\n  _getSubscribeErrorContext() {\n    const subscribeErrorContext = this._error;\n    subscribeErrorContext.channel = this.channel;\n    subscribeErrorContext.isResubscribe = this._isResubscribe;\n    return subscribeErrorContext;\n  };\n\n  ready(callback, errback) {\n    if (this._ready) {\n      if (this._isSuccess()) {\n        callback(this._getSubscribeSuccessContext());\n      } else {\n        errback(this._getSubscribeErrorContext());\n      }\n    }\n  };\n\n  subscribe() {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._noResubscribe = false;\n    this._centrifuge._subscribe(this);\n  };\n\n  unsubscribe() {\n    this._setUnsubscribed(true);\n    this._centrifuge._unsubscribe(this);\n  };\n\n  _methodCall(message, type) {\n    const methodCallPromise = new Promise((resolve, reject) => {\n      let subPromise;\n      if (this._isSuccess()) {\n        subPromise = Promise.resolve();\n      } else if (this._isError()) {\n        subPromise = Promise.reject(this._error);\n      } else {\n        subPromise = new Promise((res, rej) => {\n          const timeout = setTimeout(function () {\n            rej({'code': 0, 'message': 'timeout'});\n          }, this._centrifuge._config.timeout);\n          this._promises[timeout] = {\n            resolve: res,\n            reject: rej\n          };\n        });\n      }\n      subPromise.then(\n        () => {\n          return this._centrifuge._call(message).then(\n            result => {\n              resolve(this._centrifuge._decoder.decodeCommandResult(type, result.result));\n              if (result.next) {\n                result.next();\n              }\n            },\n            error => {\n              reject(error);\n            }\n          );\n        },\n        error => {\n          reject(error);\n        }\n      );\n    });\n    return methodCallPromise;\n  }\n\n  publish(data) {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PUBLISH,\n      params: {\n        channel: this.channel,\n        data: data\n      }\n    }, this._centrifuge._methodType.PUBLISH);\n  };\n\n  presence() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE,\n      params: {\n        channel: this.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE);\n  };\n\n  presenceStats() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE_STATS,\n      params: {\n        channel: this.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE_STATS);\n  };\n\n  history() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.HISTORY,\n      params: {\n        channel: this.channel\n      }\n    }, this._centrifuge._methodType.HISTORY);\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/subscription.js","export const JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10,\n  SUB_REFRESH: 11\n};\n\nexport const JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4\n};\n\nexport class JsonEncoder {\n  encodeCommands(commands) {\n    const encodedCommands = [];\n    for (const i in commands) {\n      if (commands.hasOwnProperty(i)) {\n        encodedCommands.push(JSON.stringify(commands[i]));\n      }\n    }\n    return encodedCommands.join('\\n');\n  }\n}\n\nexport class JsonDecoder {\n  decodeReplies(data) {\n    const replies = [];\n    const encodedReplies = data.split('\\n');\n    for (const i in encodedReplies) {\n      if (encodedReplies.hasOwnProperty(i)) {\n        if (!encodedReplies[i]) {\n          continue;\n        }\n        const reply = JSON.parse(encodedReplies[i]);\n        replies.push(reply);\n      }\n    }\n    return replies;\n  }\n\n  decodeCommandResult(methodType, data) {\n    return data;\n  }\n\n  decodePush(data) {\n    return data;\n  }\n\n  decodePushData(pushType, data) {\n    return data;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/json.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 0 1","import {Centrifuge} from './centrifuge.js';\nexport default Centrifuge;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/events/events.js\n// module id = 6\n// module chunks = 0 1","export function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nexport function log(level, args) {\n  if (global.console) {\n    const logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nexport function backoff(step, min, max) {\n  const jitter = 0.5 * Math.random();\n  const interval = Math.min(max, min * Math.pow(2, step + 1));\n\n  return Math.floor((1 - jitter) * interval);\n};\n\nexport function errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}