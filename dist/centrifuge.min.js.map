{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///centrifuge.min.js","webpack:///webpack/bootstrap bc4da11a9a456f27ec97","webpack:///./src/centrifuge.js","webpack:///./src/subscription.js","webpack:///./src/json.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/index.js","webpack:///./node_modules/events/events.js","webpack:///./src/utils.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","10","global","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","Centrifuge","undefined","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_events","_events2","_subscription","_subscription2","_json","_utils","_EventEmitter","url","options","_this","getPrototypeOf","_url","_promise","_sockjs","_isSockjs","_binary","_methodType","_pushType","_encoder","_decoder","_status","_reconnect","_reconnecting","_transport","_transportName","_transportClosed","_messageId","_clientID","_subs","_lastPubUID","_messages","_isBatching","_isAuthBatching","_authChannels","_numRefreshFailed","_refreshTimeout","_pingInterval","_pongTimeout","_retries","_callbacks","_latency","_latencyStart","_credentials","_config","debug","sockjs","promise","retry","maxRetry","timeout","resubscribe","ping","pingInterval","pongWaitTimeout","privateChannelPrefix","onTransportClose","sockjsServer","sockjsTransports","refreshEndpoint","refreshHeaders","refreshParams","refreshData","refreshAttempts","refreshInterval","onRefreshFailed","onRefresh","authEndpoint","authHeaders","authParams","onAuth","_configure","credentials","params","headers","data","callback","query","_debug","xhr","XMLHttpRequest","ActiveXObject","encodeURIComponent","open","withCredentials","setRequestHeader","headerName","onreadystatechange","readyState","status","parsed","JSON","parse","responseText","e","_log","setTimeout","send","stringify","log","arguments","WebSocket","format","_formatOverride","Error","JsonMethodType","JsonPushType","JsonEncoder","JsonDecoder","configuration","assign","Promise","startsWith","indexOf","_setFormat","SockJS","newStatus","interval","backoff","reconnect","uid","callbacks","errback","_createErrorObject","channel","sub","_isSuccess","_triggerUnsubscribe","_setSubscribing","_setUnsubscribed","commands","encodeCommands","sockjsOptions","transports","server","_websocketSupported","binaryType","onopen","transport","onheartbeat","_restartPing","_resetRetry","msg","Date","_call","then","result","_connectResponse","decodeCommandResult","CONNECT","_disconnect","onerror","error","onclose","closeEvent","reason","needReconnect","advice","event","_getRetryInterval","_connect","onmessage","replies","decodeReplies","_dispatchReply","method","RPC","resolve","reject","SEND","_callAsync","_addMessage","id","_registerCall","isConnected","_setStatus","_setupTransport","shouldReconnect","_isDisconnected","_clearConnectedState","clearTimeout","emit","close","_refreshFailed","cb","_refresh","Math","round","random","user","exp","info","sign","REFRESH","_refreshResponse","context","_ajax","_setNew","SUBSCRIBE","startAuthBatching","_subscribe","stopAuthBatching","_recover","recover","last","_getLastID","_subscribeResponse","err","_subscribeError","UNSUBSCRIBE","_getSub","getTime","expires","expired","client","ttl","startBatching","_shouldResubscribe","stopBatching","latency","clearInterval","setInterval","_stopPing","_startPing","_isSubscribing","code","message","_setSubscribeError","pubs","publications","reverse","_handlePublication","recovered","_setSubscribeSuccess","reply","errorExists","join","leave","unsubscribe","pub","push","decodePush","type","PUBLICATION","decodePushData","MESSAGE","_handleMessage","JOIN","_handleJoin","LEAVE","_handleLeave","UNSUB","_handleUnsub","_handleReply","_handlePush","messages","slice","_transportSend","PING","lastUID","isFunction","async","_nextMessageId","_isConnected","_ping","flush","_flush","authChannels","channels","batch","channelResponse","body","events","isString","currentSub","_setEvents","_isUnsubscribed","subscribe","11","_STATE_NEW","Subscription","centrifuge","_centrifuge","_error","_isResubscribe","_recovered","_ready","_noResubscribe","_initializePromise","_resolve","_reject","on","toString","knownEvents","ev","successContext","_getSubscribeSuccessContext","errContext","_getSubscribeErrorContext","noResubscribe","needTrigger","isResubscribe","subscribeErrorContext","_unsubscribe","_methodCall","PUBLISH","PRESENCE","PRESENCE_STATS","HISTORY","12","encodedCommands","encodedReplies","split","methodType","pushType","3","g","Function","eval","window","31","6","EventEmitter","_maxListeners","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","er","handler","len","args","listeners","Array","apply","addListener","listener","newListener","warned","console","trace","once","removeListener","fired","list","position","splice","removeAllListeners","listenerCount","evlistener","emitter","7","prefix","lastIndexOf","String","level","logger","step","min","max","jitter","pow","floor"],"mappings":"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","file":"centrifuge.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 31);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Centrifuge = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(6);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _subscription = __webpack_require__(11);\n\nvar _subscription2 = _interopRequireDefault(_subscription);\n\nvar _json = __webpack_require__(12);\n\nvar _utils = __webpack_require__(7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _errorTimeout = 'timeout';\n\nvar Centrifuge = exports.Centrifuge = function (_EventEmitter) {\n  _inherits(Centrifuge, _EventEmitter);\n\n  function Centrifuge(url, options) {\n    _classCallCheck(this, Centrifuge);\n\n    var _this = _possibleConstructorReturn(this, (Centrifuge.__proto__ || Object.getPrototypeOf(Centrifuge)).call(this));\n\n    _this._url = url;\n    _this._promise = null;\n    _this._sockjs = null;\n    _this._isSockjs = false;\n    _this._binary = false;\n    _this._methodType = null;\n    _this._pushType = null;\n    _this._encoder = null;\n    _this._decoder = null;\n    _this._status = 'disconnected';\n    _this._reconnect = true;\n    _this._reconnecting = false;\n    _this._transport = null;\n    _this._transportName = null;\n    _this._transportClosed = true;\n    _this._messageId = 0;\n    _this._clientID = null;\n    _this._subs = {};\n    _this._lastPubUID = {};\n    _this._messages = [];\n    _this._isBatching = false;\n    _this._isAuthBatching = false;\n    _this._authChannels = {};\n    _this._numRefreshFailed = 0;\n    _this._refreshTimeout = null;\n    _this._pingInterval = null;\n    _this._pongTimeout = null;\n    _this._retries = 0;\n    _this._callbacks = {};\n    _this._latency = null;\n    _this._latencyStart = null;\n    _this._credentials = null;\n    _this._config = {\n      debug: false,\n      sockjs: null,\n      promise: null,\n      retry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      resubscribe: true,\n      ping: true,\n      pingInterval: 30000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: ['websocket', 'xdr-streaming', 'xhr-streaming', 'eventsource', 'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 3000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      authEndpoint: '/centrifuge/auth',\n      authHeaders: {},\n      authParams: {},\n      onAuth: null\n    };\n    _this._configure(options);\n    return _this;\n  }\n\n  _createClass(Centrifuge, [{\n    key: 'setCredentials',\n    value: function setCredentials(credentials) {\n      this._credentials = credentials;\n    }\n  }, {\n    key: '_ajax',\n    value: function _ajax(url, params, headers, data, callback) {\n      var self = this;\n      var query = '';\n\n      self._debug('sending AJAX request to', url);\n\n      var xhr = global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP');\n\n      for (var i in params) {\n        if (params.hasOwnProperty(i)) {\n          if (query.length > 0) {\n            query += '&';\n          }\n          query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n        }\n      }\n      if (query.length > 0) {\n        query = '?' + query;\n      }\n      xhr.open('POST', url + query, true);\n      if ('withCredentials' in xhr) {\n        xhr.withCredentials = true;\n      }\n\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      for (var headerName in headers) {\n        if (headers.hasOwnProperty(headerName)) {\n          xhr.setRequestHeader(headerName, headers[headerName]);\n        }\n      }\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            var _data = void 0,\n                parsed = false;\n\n            try {\n              _data = JSON.parse(xhr.responseText);\n              parsed = true;\n            } catch (e) {\n              callback(true, 'JSON returned was invalid, yet status code was 200. Data was: ' + xhr.responseText);\n            }\n            if (parsed) {\n              // prevents double execution.\n              callback(false, _data);\n            }\n          } else {\n            self._log(\"Couldn't get auth info from application\", xhr.status);\n            callback(true, xhr.status);\n          }\n        }\n      };\n\n      setTimeout(function () {\n        xhr.send(JSON.stringify(data));\n      }, 20);\n      return xhr;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      (0, _utils.log)('info', arguments);\n    }\n  }, {\n    key: '_debug',\n    value: function _debug() {\n      if (this._config.debug === true) {\n        (0, _utils.log)('debug', arguments);\n      }\n    }\n  }, {\n    key: '_websocketSupported',\n    value: function _websocketSupported() {\n      return !(typeof WebSocket !== 'function' && (typeof WebSocket === 'undefined' ? 'undefined' : _typeof(WebSocket)) !== 'object');\n    }\n  }, {\n    key: '_setFormat',\n    value: function _setFormat(format) {\n      if (this._formatOverride(format)) {\n        return;\n      }\n      if (format === 'protobuf') {\n        throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n      }\n      this._binary = false;\n      this._methodType = _json.JsonMethodType;\n      this._pushType = _json.JsonPushType;\n      this._encoder = new _json.JsonEncoder();\n      this._decoder = new _json.JsonDecoder();\n    }\n  }, {\n    key: '_formatOverride',\n    value: function _formatOverride(format) {\n      return false;\n    }\n  }, {\n    key: '_configure',\n    value: function _configure(configuration) {\n      Object.assign(this._config, configuration || {});\n      this._debug('centrifuge config', this._config);\n\n      if (!this._url) {\n        throw new Error('url required');\n      }\n\n      if (this._config.promise !== null) {\n        this._promise = this._config.promise;\n      } else {\n        if (!global.Promise) {\n          throw new Error('Promise polyfill required');\n        }\n        this._promise = global.Promise;\n      }\n\n      if ((0, _utils.startsWith)(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n        this._setFormat('protobuf');\n      } else {\n        this._setFormat('json');\n      }\n\n      if ((0, _utils.startsWith)(this._url, 'http')) {\n        this._debug('client will try to connect to SockJS endpoint');\n        if (this._config.sockjs !== null) {\n          this._debug('SockJS explicitly provided in options');\n          this._sockjs = this._config.sockjs;\n        } else {\n          if (typeof global.SockJS === 'undefined') {\n            throw new Error('SockJS not found, use ws:// in url or include SockJS');\n          }\n          this._debug('use globally defined SockJS');\n          this._sockjs = global.SockJS;\n        }\n      } else {\n        this._debug('client will connect to websocket endpoint');\n      }\n    }\n  }, {\n    key: '_setStatus',\n    value: function _setStatus(newStatus) {\n      if (this._status !== newStatus) {\n        this._debug('Status', this._status, '->', newStatus);\n        this._status = newStatus;\n      }\n    }\n  }, {\n    key: '_isDisconnected',\n    value: function _isDisconnected() {\n      return this._status === 'disconnected';\n    }\n  }, {\n    key: '_isConnecting',\n    value: function _isConnecting() {\n      return this._status === 'connecting';\n    }\n  }, {\n    key: '_isConnected',\n    value: function _isConnected() {\n      return this._status === 'connected';\n    }\n  }, {\n    key: '_nextMessageId',\n    value: function _nextMessageId() {\n      return ++this._messageId;\n    }\n  }, {\n    key: '_resetRetry',\n    value: function _resetRetry() {\n      this._debug('reset retries count to 0');\n      this._retries = 0;\n    }\n  }, {\n    key: '_getRetryInterval',\n    value: function _getRetryInterval() {\n      var interval = (0, _utils.backoff)(this._retries, this._config.retry, this._config.maxRetry);\n\n      this._retries += 1;\n      return interval;\n    }\n  }, {\n    key: '_clearConnectedState',\n    value: function _clearConnectedState(reconnect) {\n      this._clientID = null;\n\n      // fire errbacks of registered outgoing calls.\n      for (var uid in this._callbacks) {\n        if (this._callbacks.hasOwnProperty(uid)) {\n          var callbacks = this._callbacks[uid];\n          var errback = callbacks.errback;\n          if (!errback) {\n            continue;\n          }\n          errback(this._createErrorObject('disconnected'));\n        }\n      }\n      this._callbacks = {};\n\n      // fire unsubscribe events\n      for (var channel in this._subs) {\n        if (this._subs.hasOwnProperty(channel)) {\n          var sub = this._subs[channel];\n\n          if (reconnect) {\n            if (sub._isSuccess()) {\n              sub._triggerUnsubscribe();\n            }\n            sub._setSubscribing();\n          } else {\n            sub._setUnsubscribed();\n          }\n        }\n      }\n\n      if (!this._config.resubscribe || !this._reconnect) {\n        // completely clear connected state\n        this._subs = {};\n      }\n    }\n  }, {\n    key: '_transportSend',\n    value: function _transportSend(commands) {\n      if (!commands.length) {\n        return;\n      }\n      if (!this._transport) {\n        throw new Error('transport not connected');\n      }\n      this._transport.send(this._encoder.encodeCommands(commands));\n    }\n  }, {\n    key: '_setupTransport',\n    value: function _setupTransport() {\n      var self = this;\n      this._isSockjs = false;\n\n      // detect transport to use - SockJS or Websocket\n      if (this._sockjs !== null) {\n        var sockjsOptions = {\n          transports: this._config.sockjsTransports\n        };\n\n        if (this._config.sockjsServer !== null) {\n          sockjsOptions.server = this._config.sockjsServer;\n        }\n        this._isSockjs = true;\n        this._transport = new this._sockjs(this._url, null, sockjsOptions);\n      } else {\n        if (!this._websocketSupported()) {\n          this._debug('No Websocket support and no SockJS configured, can not connect');\n          return;\n        }\n        this._transport = new WebSocket(this._url);\n        if (this._binary === true) {\n          this._transport.binaryType = 'arraybuffer';\n        }\n      }\n\n      this._transport.onopen = function () {\n        self._transportClosed = false;\n        self._reconnecting = false;\n        if (self._isSockjs) {\n          self._transportName = 'sockjs-' + self._transport.transport;\n          self._transport.onheartbeat = function () {\n            self._restartPing();\n          };\n        } else {\n          self._transportName = 'websocket';\n        }\n\n        self._resetRetry();\n\n        // Can omit method here due to zero value.\n        var msg = {\n          // method: self._methodType.CONNECT\n        };\n\n        if (self._credentials) {\n          msg.params = self._credentials;\n        }\n\n        self._latencyStart = new Date();\n        self._call(msg).then(function (result) {\n          self._connectResponse(self._decoder.decodeCommandResult(self._methodType.CONNECT, result));\n        }, function () {\n          self._disconnect('connect error', true);\n        });\n      };\n\n      this._transport.onerror = function (error) {\n        self._debug('transport level error', error);\n      };\n\n      this._transport.onclose = function (closeEvent) {\n        self._transportClosed = true;\n        var reason = 'connection closed';\n        var needReconnect = true;\n\n        if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n          try {\n            var advice = JSON.parse(closeEvent.reason);\n\n            self._debug('reason is an advice object', advice);\n            reason = advice.reason;\n            needReconnect = advice.reconnect;\n          } catch (e) {\n            reason = closeEvent.reason;\n            self._debug('reason is a plain string', reason);\n            needReconnect = reason !== 'disconnect';\n          }\n        }\n\n        // onTransportClose callback should be executed every time transport was closed.\n        // This can be helpful to catch failed connection events (because our disconnect\n        // event only called once and every future attempts to connect do not fire disconnect\n        // event again).\n        if (self._config.onTransportClose !== null) {\n          self._config.onTransportClose({\n            event: closeEvent,\n            reason: reason,\n            reconnect: needReconnect\n          });\n        }\n\n        self._disconnect(reason, needReconnect);\n\n        if (self._reconnect === true) {\n          self._reconnecting = true;\n          var interval = self._getRetryInterval();\n\n          self._debug('reconnect after ' + interval + ' milliseconds');\n          setTimeout(function () {\n            if (self._reconnect === true) {\n              self._connect.call(self);\n            }\n          }, interval);\n        }\n      };\n\n      this._transport.onmessage = function (event) {\n        var replies = self._decoder.decodeReplies(event.data);\n        for (var i in replies) {\n          if (replies.hasOwnProperty(i)) {\n            self._debug('Received reply', replies[i]);\n            self._dispatchReply(replies[i]);\n          }\n        }\n        self._restartPing();\n      };\n    }\n  }, {\n    key: 'rpc',\n    value: function rpc(data) {\n      var self = this;\n      var msg = {\n        method: self._methodType.RPC,\n        params: {\n          data: data\n        }\n      };\n      var promise = this._call(msg);\n\n      return new self._promise(function (resolve, reject) {\n        promise.then(function (result) {\n          resolve(self._decoder.decodeCommandResult(self._methodType.RPC, result));\n        }, function (error) {\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: 'send',\n    value: function send(data) {\n      var msg = {\n        method: this._methodType.SEND,\n        params: {\n          data: data\n        }\n      };\n\n      return this._callAsync(msg);\n    }\n  }, {\n    key: '_callAsync',\n    value: function _callAsync(msg) {\n      this._addMessage(msg, true);\n    }\n  }, {\n    key: '_call',\n    value: function _call(msg) {\n      var self = this;\n\n      return new self._promise(function (resolve, reject) {\n        var id = self._addMessage(msg);\n        self._registerCall(id, resolve, reject);\n      });\n    }\n  }, {\n    key: '_connect',\n    value: function _connect() {\n      if (this.isConnected()) {\n        this._debug('connect called when already connected');\n        return;\n      }\n      if (this._status === 'connecting') {\n        return;\n      }\n\n      this._debug('start connecting');\n      this._setStatus('connecting');\n      this._clientID = null;\n      this._reconnect = true;\n      this._setupTransport();\n    }\n  }, {\n    key: '_disconnect',\n    value: function _disconnect(reason, shouldReconnect) {\n\n      if (this._isDisconnected()) {\n        return;\n      }\n\n      this._debug('disconnected:', reason, shouldReconnect);\n\n      var reconnect = shouldReconnect || false;\n\n      if (reconnect === false) {\n        this._reconnect = false;\n      }\n\n      this._clearConnectedState(reconnect);\n\n      if (!this._isDisconnected()) {\n        this._setStatus('disconnected');\n        if (this._refreshTimeout) {\n          clearTimeout(this._refreshTimeout);\n        }\n        if (this._reconnecting === false) {\n          this.emit('disconnect', {\n            reason: reason,\n            reconnect: reconnect\n          });\n        }\n      }\n\n      if (!this._transportClosed) {\n        this._transport.close();\n      }\n    }\n  }, {\n    key: '_refreshFailed',\n    value: function _refreshFailed() {\n      this._numRefreshFailed = 0;\n      if (!this._isDisconnected()) {\n        this._disconnect('refresh failed', false);\n      }\n      if (this._config.onRefreshFailed !== null) {\n        this._config.onRefreshFailed();\n      }\n    }\n  }, {\n    key: '_refresh',\n    value: function _refresh() {\n      // ask web app for connection parameters - user ID,\n      // timestamp, info and token\n      var self = this;\n\n      this._debug('refresh credentials');\n\n      if (self._config.refreshAttempts === 0) {\n        this._debug('refresh attempts set to 0, do not send refresh request at all');\n        self._refreshFailed();\n        return;\n      }\n\n      if (self._refreshTimeout !== null) {\n        clearTimeout(self._refreshTimeout);\n      }\n\n      var cb = function cb(error, data) {\n        if (error === true) {\n          // We don't perform any connection status related actions here as we are\n          // relying on Centrifugo that must close connection eventually.\n          self._debug('error getting connection credentials from refresh endpoint', data);\n          self._numRefreshFailed++;\n          if (self._refreshTimeout) {\n            clearTimeout(self._refreshTimeout);\n          }\n          if (self._config.refreshAttempts !== null && self._numRefreshFailed >= self._config.refreshAttempts) {\n            self._refreshFailed();\n            return;\n          }\n          self._refreshTimeout = setTimeout(function () {\n            self._refresh.call(self);\n          }, self._config.refreshInterval + Math.round(Math.random() * 1000));\n          return;\n        }\n        self._numRefreshFailed = 0;\n        if (self._credentials === null) {\n          return;\n        }\n        self._credentials.user = data.user;\n        self._credentials.exp = data.exp;\n        if ('info' in data) {\n          self._credentials.info = data.info;\n        }\n        self._credentials.sign = data.sign;\n        if (self._isDisconnected()) {\n          self._debug('credentials refreshed, connect from scratch');\n          self._connect();\n        } else {\n          self._debug('send refreshed credentials');\n\n          var msg = {\n            method: self._methodType.REFRESH,\n            params: self._credentials\n          };\n\n          self._call(msg).then(function (result) {\n            self._refreshResponse(self._decoder.decodeCommandResult(self._methodType.REFRESH, result));\n          }, function () {\n            self._disconnect('refresh error', true);\n          });\n        }\n      };\n\n      if (this._config.onRefresh !== null) {\n        var context = {};\n        this._config.onRefresh(context, cb);\n      } else {\n        this._ajax(this._config.refreshEndpoint, this._config.refreshParams, this._config.refreshHeaders, this._config.refreshData, cb);\n      }\n    }\n  }, {\n    key: '_subscribe',\n    value: function _subscribe(sub) {\n\n      var channel = sub.channel;\n\n      if (!(channel in this._subs)) {\n        this._subs[channel] = sub;\n      }\n\n      if (!this.isConnected()) {\n        // subscribe will be called later\n        sub._setNew();\n        return;\n      }\n\n      sub._setSubscribing();\n\n      var msg = {\n        method: this._methodType.SUBSCRIBE,\n        params: {\n          channel: channel\n        }\n      };\n\n      // If channel name does not start with privateChannelPrefix - then we\n      // can just send subscription message to Centrifuge. If channel name\n      // starts with privateChannelPrefix - then this is a private channel\n      // and we should ask web application backend for permission first.\n      if ((0, _utils.startsWith)(channel, this._config.privateChannelPrefix)) {\n        // private channel\n        if (this._isAuthBatching) {\n          this._authChannels[channel] = true;\n        } else {\n          this.startAuthBatching();\n          this._subscribe(sub);\n          this.stopAuthBatching();\n        }\n      } else {\n        var recover = this._recover(channel);\n\n        if (recover === true) {\n          msg.params.recover = true;\n          msg.params.last = this._getLastID(channel);\n        }\n        var self = this;\n\n        this._call(msg).then(function (result) {\n          self._subscribeResponse(channel, self._decoder.decodeCommandResult(self._methodType.SUBSCRIBE, result));\n        }, function (err) {\n          self._subscribeError(err);\n        });\n      }\n    }\n  }, {\n    key: '_unsubscribe',\n    value: function _unsubscribe(sub) {\n      if (this.isConnected()) {\n        // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n        this._addMessage({\n          method: this._methodType.UNSUBSCRIBE,\n          params: {\n            channel: sub.channel\n          }\n        });\n      }\n    }\n  }, {\n    key: 'getSub',\n    value: function getSub(channel) {\n      return this._getSub(channel);\n    }\n  }, {\n    key: '_getSub',\n    value: function _getSub(channel) {\n      var sub = this._subs[channel];\n      if (!sub) {\n        return null;\n      }\n      return sub;\n    }\n  }, {\n    key: '_connectResponse',\n    value: function _connectResponse(result) {\n      if (this.isConnected()) {\n        return;\n      }\n\n      if (this._latencyStart !== null) {\n        this._latency = new Date().getTime() - this._latencyStart.getTime();\n        this._latencyStart = null;\n      }\n\n      if (result.expires) {\n        var isExpired = result.expired;\n\n        if (isExpired) {\n          this._reconnecting = true;\n          this._disconnect('expired', true);\n          this._refresh();\n          return;\n        }\n      }\n      this._clientID = result.client;\n      this._setStatus('connected');\n\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n      }\n\n      var self = this;\n\n      if (result.expires) {\n        this._refreshTimeout = setTimeout(function () {\n          self._refresh.call(self);\n        }, result.ttl * 1000);\n      }\n\n      if (this._config.resubscribe) {\n        this.startBatching();\n        this.startAuthBatching();\n        for (var channel in this._subs) {\n          if (this._subs.hasOwnProperty(channel)) {\n            var sub = this._subs[channel];\n            if (sub._shouldResubscribe()) {\n              this._subscribe(sub);\n            }\n          }\n        }\n        this.stopAuthBatching();\n        this.stopBatching(true);\n      }\n\n      this._restartPing();\n      this.emit('connect', {\n        client: result.client,\n        transport: this._transportName,\n        latency: this._latency\n      });\n    }\n  }, {\n    key: '_stopPing',\n    value: function _stopPing() {\n      if (this._pongTimeout !== null) {\n        clearTimeout(this._pongTimeout);\n      }\n      if (this._pingInterval !== null) {\n        clearInterval(this._pingInterval);\n      }\n    }\n  }, {\n    key: '_startPing',\n    value: function _startPing() {\n      if (this._config.ping !== true || this._config.pingInterval <= 0) {\n        return;\n      }\n      if (!this.isConnected()) {\n        return;\n      }\n\n      var self = this;\n\n      this._pingInterval = setInterval(function () {\n        if (!self.isConnected()) {\n          self._stopPing();\n          return;\n        }\n        self.ping();\n        self._pongTimeout = setTimeout(function () {\n          self._disconnect('no ping', true);\n        }, self._config.pongWaitTimeout);\n      }, this._config.pingInterval);\n    }\n  }, {\n    key: '_restartPing',\n    value: function _restartPing() {\n      this._stopPing();\n      this._startPing();\n    }\n  }, {\n    key: '_subscribeError',\n    value: function _subscribeError(channel, error) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      if (!sub._isSubscribing()) {\n        return;\n      }\n      if (error.code === 0 && error.message === _errorTimeout) {\n        // client side timeout.\n        this._disconnect('timeout', true);\n        return;\n      }\n      sub._setSubscribeError(error);\n    }\n  }, {\n    key: '_subscribeResponse',\n    value: function _subscribeResponse(channel, result) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      if (!sub._isSubscribing()) {\n        return;\n      }\n\n      var pubs = result.publications;\n\n      if (pubs && pubs.length > 0) {\n        // handle missed pubs.\n        pubs = pubs.reverse();\n        for (var i in pubs) {\n          if (pubs.hasOwnProperty(i)) {\n            this._handlePublication(channel, pubs[i]);\n          }\n        }\n      } else {\n        if ('last' in result) {\n          // no missed messages found so set last message id from result.\n          this._lastPubUID[channel] = result.last;\n        }\n      }\n\n      var recovered = false;\n\n      if ('recovered' in result) {\n        recovered = result.recovered;\n      }\n      sub._setSubscribeSuccess(recovered);\n    }\n  }, {\n    key: '_handleReply',\n    value: function _handleReply(reply) {\n      var id = reply.id;\n      var result = reply.result;\n\n      if (!(id in this._callbacks)) {\n        return;\n      }\n      var callbacks = this._callbacks[id];\n      delete this._callbacks[id];\n\n      if (!(0, _utils.errorExists)(reply)) {\n        var callback = callbacks.callback;\n        if (!callback) {\n          return;\n        }\n        callback(result);\n      } else {\n        var errback = callbacks.errback;\n        if (!errback) {\n          return;\n        }\n        errback(reply.error);\n      }\n    }\n  }, {\n    key: '_handleJoin',\n    value: function _handleJoin(channel, join) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      sub.emit('join', join);\n    }\n  }, {\n    key: '_handleLeave',\n    value: function _handleLeave(channel, leave) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      sub.emit('leave', leave);\n    }\n  }, {\n    key: '_handleUnsub',\n    value: function _handleUnsub(channel) {\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      sub.unsubscribe();\n    }\n  }, {\n    key: '_handlePublication',\n    value: function _handlePublication(channel, pub) {\n      // keep last uid received from channel.\n      this._lastPubUID[channel] = pub.uid;\n      var sub = this._getSub(channel);\n      if (!sub) {\n        return;\n      }\n      sub.emit('publication', pub);\n    }\n  }, {\n    key: '_handleMessage',\n    value: function _handleMessage(message) {\n      this.emit('message', message.data);\n    }\n  }, {\n    key: '_refreshResponse',\n    value: function _refreshResponse(result) {\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n      }\n      if (result.expires) {\n        var self = this;\n        var expired = result.expired;\n\n        if (expired) {\n          self._refreshTimeout = setTimeout(function () {\n            self._refresh.call(self);\n          }, self._config.refreshInterval + Math.round(Math.random() * 1000));\n          return;\n        }\n        this._clientID = result.client;\n        self._refreshTimeout = setTimeout(function () {\n          self._refresh.call(self);\n        }, result.ttl * 1000);\n      }\n    }\n  }, {\n    key: '_handlePush',\n    value: function _handlePush(data) {\n      var push = this._decoder.decodePush(data);\n      var type = 0;\n      if ('type' in push) {\n        type = push['type'];\n      }\n      var channel = push.channel;\n\n      if (type === this._pushType.PUBLICATION) {\n        var pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n        this._handlePublication(channel, pub);\n      } else if (type === this._pushType.MESSAGE) {\n        var message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n        this._handleMessage(message);\n      } else if (type === this._pushType.JOIN) {\n        var join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n        this._handleJoin(channel, join);\n      } else if (type === this._pushType.LEAVE) {\n        var leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n        this._handleLeave(channel, leave);\n      } else if (type === this._pushType.UNSUB) {\n        this._handleUnsub(channel);\n      }\n    }\n  }, {\n    key: '_dispatchReply',\n    value: function _dispatchReply(reply) {\n      if (reply === undefined || reply === null) {\n        this._debug('dispatch: got undefined or null reply');\n        return;\n      }\n\n      var id = reply.id;\n\n      if (id && id > 0) {\n        this._handleReply(reply);\n      } else {\n        this._handlePush(reply.result);\n      }\n    }\n  }, {\n    key: '_flush',\n    value: function _flush() {\n      var messages = this._messages.slice(0);\n      this._messages = [];\n      this._transportSend(messages);\n    }\n  }, {\n    key: '_ping',\n    value: function _ping() {\n      this._addMessage({\n        method: this._methodType.PING\n      });\n    }\n  }, {\n    key: '_recover',\n    value: function _recover(channel) {\n      return channel in this._lastPubUID;\n    }\n  }, {\n    key: '_getLastID',\n    value: function _getLastID(channel) {\n      var lastUID = this._lastPubUID[channel];\n\n      if (lastUID) {\n        this._debug('last uid found and sent for channel', channel);\n        return lastUID;\n      }\n      this._debug('no last uid found for channel', channel);\n      return '';\n    }\n  }, {\n    key: '_createErrorObject',\n    value: function _createErrorObject(message, code) {\n      var errObject = {\n        message: message,\n        code: code || 0\n      };\n\n      return errObject;\n    }\n  }, {\n    key: '_registerCall',\n    value: function _registerCall(id, callback, errback) {\n      var self = this;\n\n      this._callbacks[id] = {\n        callback: callback,\n        errback: errback\n      };\n      setTimeout(function () {\n        delete self._callbacks[id];\n        if ((0, _utils.isFunction)(errback)) {\n          errback(self._createErrorObject(_errorTimeout));\n        }\n      }, this._config.timeout);\n    }\n  }, {\n    key: '_addMessage',\n    value: function _addMessage(message, async) {\n      var id = void 0;\n      if (!async) {\n        id = this._nextMessageId();\n        message.id = id;\n      }\n      if (this._isBatching === true) {\n        this._messages.push(message);\n      } else {\n        this._transportSend([message]);\n      }\n      if (!async) {\n        return id;\n      }\n      return 0;\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._isConnected();\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      this._connect();\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      this._disconnect('client', false);\n    }\n  }, {\n    key: 'ping',\n    value: function ping() {\n      return this._ping();\n    }\n  }, {\n    key: 'startBatching',\n    value: function startBatching() {\n      // start collecting messages without sending them to Centrifuge until flush\n      // method called\n      this._isBatching = true;\n    }\n  }, {\n    key: 'stopBatching',\n    value: function stopBatching(flush) {\n      // stop collecting messages\n      flush = flush || false;\n      this._isBatching = false;\n      if (flush === true) {\n        this.flush();\n      }\n    }\n  }, {\n    key: 'flush',\n    value: function flush() {\n      // send batched messages to Centrifuge\n      this._flush();\n    }\n  }, {\n    key: 'startAuthBatching',\n    value: function startAuthBatching() {\n      // start collecting private channels to create bulk authentication\n      // request to authEndpoint when stopAuthBatching will be called\n      this._isAuthBatching = true;\n    }\n  }, {\n    key: 'stopAuthBatching',\n    value: function stopAuthBatching() {\n      var i, channel;\n\n      // create request to authEndpoint with collected private channels\n      // to ask if this client can subscribe on each channel\n      this._isAuthBatching = false;\n      var authChannels = this._authChannels;\n\n      this._authChannels = {};\n      var channels = [];\n\n      for (channel in authChannels) {\n        if (authChannels.hasOwnProperty(channel)) {\n          var sub = this._getSub(channel);\n\n          if (!sub) {\n            continue;\n          }\n          channels.push(channel);\n        }\n      }\n\n      if (channels.length === 0) {\n        return;\n      }\n\n      var data = {\n        client: this._clientID,\n        channels: channels\n      };\n\n      var self = this;\n\n      var cb = function cb(error, data) {\n        if (error === true) {\n          self._debug('authorization request failed');\n          for (i in channels) {\n            if (channels.hasOwnProperty(i)) {\n              channel = channels[i];\n              self._subscribeResponse({\n                error: 'authorization request failed',\n                body: {\n                  channel: channel\n                }\n              });\n            }\n          }\n          return;\n        }\n\n        // try to send all subscriptions in one request.\n        var batch = false;\n\n        if (!self._isBatching) {\n          self.startBatching();\n          batch = true;\n        }\n\n        for (i in channels) {\n          if (channels.hasOwnProperty(i)) {\n            channel = channels[i];\n            var channelResponse = data[channel];\n\n            if (!channelResponse) {\n              // subscription:error\n              self._subscribeResponse({\n                error: 'channel not found in authorization response',\n                body: {\n                  channel: channel\n                }\n              });\n              continue;\n            }\n            if (!channelResponse.status || channelResponse.status === 200) {\n              var msg = {\n                method: self._methodType.SUBSCRIBE,\n                params: {\n                  channel: channel,\n                  client: self._clientID,\n                  info: channelResponse.info,\n                  sign: channelResponse.sign\n                }\n              };\n              var recover = self._recover(channel);\n\n              if (recover === true) {\n                msg.params.recover = true;\n                msg.params.last = self._getLastID(channel);\n              }\n              self._call(msg).then(function (result) {\n                self._subscribeResponse(channel, self._decoder.decodeCommandResult(self._methodType.SUBSCRIBE, result));\n              }, function (err) {\n                self._subscribeError(channel, err);\n              });\n            } else {\n              self._subscribeResponse({\n                error: channelResponse.status,\n                body: {\n                  channel: channel\n                }\n              });\n            }\n          }\n        }\n\n        if (batch) {\n          self.stopBatching(true);\n        }\n      };\n\n      if (this._config.onAuth !== null) {\n        this._config.onAuth({\n          data: data\n        }, cb);\n      } else {\n        this._ajax(this._config.authEndpoint, this._config.authParams, this._config.authHeaders, data, cb);\n      }\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe(channel, events) {\n      if (arguments.length < 1) {\n        throw new Error('Illegal arguments number: required 1, got ' + arguments.length);\n      }\n      if (!(0, _utils.isString)(channel)) {\n        throw new Error('Illegal argument type: channel must be a string');\n      }\n      if (!this._config.resubscribe && !this.isConnected()) {\n        throw new Error('Can not only subscribe in connected state when resubscribe option is off');\n      }\n\n      var currentSub = this._getSub(channel);\n\n      if (currentSub !== null) {\n        currentSub._setEvents(events);\n        if (currentSub._isUnsubscribed()) {\n          currentSub.subscribe();\n        }\n        return currentSub;\n      }\n      var sub = new _subscription2.default(this, channel, events);\n      this._subs[channel] = sub;\n      sub.subscribe();\n      return sub;\n    }\n  }]);\n\n  return Centrifuge;\n}(_events2.default);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(6);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _utils = __webpack_require__(7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _STATE_NEW = 0;\nvar _STATE_SUBSCRIBING = 1;\nvar _STATE_SUCCESS = 2;\nvar _STATE_ERROR = 3;\nvar _STATE_UNSUBSCRIBED = 4;\n\nvar Subscription = function (_EventEmitter) {\n  _inherits(Subscription, _EventEmitter);\n\n  function Subscription(centrifuge, channel, events) {\n    _classCallCheck(this, Subscription);\n\n    var _this = _possibleConstructorReturn(this, (Subscription.__proto__ || Object.getPrototypeOf(Subscription)).call(this));\n\n    _this.channel = channel;\n    _this._centrifuge = centrifuge;\n    _this._status = _STATE_NEW;\n    _this._error = null;\n    _this._isResubscribe = false;\n    _this._recovered = false;\n    _this._ready = false;\n    _this._promise = null;\n    _this._noResubscribe = false;\n    _this._setEvents(events);\n    _this._initializePromise();\n    return _this;\n  }\n\n  _createClass(Subscription, [{\n    key: '_initializePromise',\n    value: function _initializePromise() {\n      // this helps us to wait until subscription will successfully\n      // subscribe and call actions such as presence, history etc in\n      // synchronous way.\n      var self = this;\n\n      this._ready = false;\n\n      this._promise = new Promise(function (resolve, reject) {\n        self._resolve = function (value) {\n          self._ready = true;\n          resolve(value);\n        };\n        self._reject = function (err) {\n          self._ready = true;\n          reject(err);\n        };\n      });\n    }\n  }, {\n    key: '_setEvents',\n    value: function _setEvents(events) {\n      if (!events) {\n        return;\n      }\n      if ((0, _utils.isFunction)(events)) {\n        // events is just a function to handle publication received from channel.\n        this.on('publication', events);\n      } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n        var knownEvents = ['publication', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n        for (var i = 0, l = knownEvents.length; i < l; i++) {\n          var ev = knownEvents[i];\n          if (ev in events) {\n            this.on(ev, events[ev]);\n          }\n        }\n      }\n    }\n  }, {\n    key: '_isNew',\n    value: function _isNew() {\n      return this._status === _STATE_NEW;\n    }\n  }, {\n    key: '_isUnsubscribed',\n    value: function _isUnsubscribed() {\n      return this._status === _STATE_UNSUBSCRIBED;\n    }\n  }, {\n    key: '_isSubscribing',\n    value: function _isSubscribing() {\n      return this._status === _STATE_SUBSCRIBING;\n    }\n  }, {\n    key: '_isReady',\n    value: function _isReady() {\n      return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n    }\n  }, {\n    key: '_isSuccess',\n    value: function _isSuccess() {\n      return this._status === _STATE_SUCCESS;\n    }\n  }, {\n    key: '_isError',\n    value: function _isError() {\n      return this._status === _STATE_ERROR;\n    }\n  }, {\n    key: '_setNew',\n    value: function _setNew() {\n      this._status = _STATE_NEW;\n    }\n  }, {\n    key: '_setSubscribing',\n    value: function _setSubscribing() {\n      if (this._ready === true) {\n        // new promise for this subscription\n        this._initializePromise();\n        this._isResubscribe = true;\n      }\n      this._status = _STATE_SUBSCRIBING;\n    }\n  }, {\n    key: '_setSubscribeSuccess',\n    value: function _setSubscribeSuccess(recovered) {\n      if (this._status === _STATE_SUCCESS) {\n        return;\n      }\n      this._recovered = recovered;\n      this._status = _STATE_SUCCESS;\n      var successContext = this._getSubscribeSuccessContext(recovered);\n\n      this.emit('subscribe', successContext);\n      this._resolve(successContext);\n    }\n  }, {\n    key: '_setSubscribeError',\n    value: function _setSubscribeError(err) {\n      if (this._status === _STATE_ERROR) {\n        return;\n      }\n      this._status = _STATE_ERROR;\n      this._error = err;\n      var errContext = this._getSubscribeErrorContext();\n\n      this.emit('error', errContext);\n      this._reject(errContext);\n    }\n  }, {\n    key: '_triggerUnsubscribe',\n    value: function _triggerUnsubscribe() {\n      this.emit('unsubscribe', {\n        channel: this.channel\n      });\n    }\n  }, {\n    key: '_setUnsubscribed',\n    value: function _setUnsubscribed(noResubscribe) {\n      if (this._status === _STATE_UNSUBSCRIBED) {\n        return;\n      }\n      var needTrigger = this._status === _STATE_SUCCESS;\n      this._status = _STATE_UNSUBSCRIBED;\n      if (noResubscribe === true) {\n        this._noResubscribe = true;\n      }\n      if (needTrigger) {\n        this._triggerUnsubscribe();\n      }\n    }\n  }, {\n    key: '_shouldResubscribe',\n    value: function _shouldResubscribe() {\n      return !this._noResubscribe;\n    }\n  }, {\n    key: '_getSubscribeSuccessContext',\n    value: function _getSubscribeSuccessContext() {\n      return {\n        channel: this.channel,\n        isResubscribe: this._isResubscribe,\n        recovered: this._recovered\n      };\n    }\n  }, {\n    key: '_getSubscribeErrorContext',\n    value: function _getSubscribeErrorContext() {\n      var subscribeErrorContext = this._error;\n      subscribeErrorContext.channel = this.channel;\n      subscribeErrorContext.isResubscribe = this._isResubscribe;\n      return subscribeErrorContext;\n    }\n  }, {\n    key: 'ready',\n    value: function ready(callback, errback) {\n      if (this._ready) {\n        if (this._isSuccess()) {\n          callback(this._getSubscribeSuccessContext());\n        } else {\n          errback(this._getSubscribeErrorContext());\n        }\n      }\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe() {\n      if (this._status === _STATE_SUCCESS) {\n        return;\n      }\n      this._centrifuge._subscribe(this);\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      this._setUnsubscribed(true);\n      this._centrifuge._unsubscribe(this);\n    }\n  }, {\n    key: '_methodCall',\n    value: function _methodCall(message, type) {\n      var self = this;\n      return new self._centrifuge._promise(function (resolve, reject) {\n        self._promise.then(function () {\n          self._centrifuge._call(message).then(function (result) {\n            resolve(self._centrifuge._decoder.decodeCommandResult(type, result));\n          }, function (err) {\n            reject(err);\n          });\n        }, function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: 'publish',\n    value: function publish(data) {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PUBLISH,\n        params: {\n          channel: self.channel,\n          data: data\n        }\n      }, this._centrifuge._methodType.PUBLISH);\n    }\n  }, {\n    key: 'presence',\n    value: function presence() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PRESENCE,\n        params: {\n          channel: self.channel\n        }\n      }, this._centrifuge._methodType.PRESENCE);\n    }\n  }, {\n    key: 'presenceStats',\n    value: function presenceStats() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.PRESENCE_STATS,\n        params: {\n          channel: self.channel\n        }\n      }, this._centrifuge._methodType.PRESENCE_STATS);\n    }\n  }, {\n    key: 'history',\n    value: function history() {\n      return this._methodCall({\n        method: this._centrifuge._methodType.HISTORY,\n        params: {\n          channel: self.channel\n        }\n      }, this._centrifuge._methodType.HISTORY);\n    }\n  }]);\n\n  return Subscription;\n}(_events2.default);\n\nexports.default = Subscription;\nmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 12:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JsonMethodType = exports.JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10\n};\n\nvar JsonPushType = exports.JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4\n};\n\nvar JsonEncoder = exports.JsonEncoder = function () {\n  function JsonEncoder() {\n    _classCallCheck(this, JsonEncoder);\n  }\n\n  _createClass(JsonEncoder, [{\n    key: 'encodeCommands',\n    value: function encodeCommands(commands) {\n      var encodedCommands = [];\n      for (var i in commands) {\n        if (commands.hasOwnProperty(i)) {\n          encodedCommands.push(JSON.stringify(commands[i]));\n        }\n      }\n      return encodedCommands.join('\\n');\n    }\n  }]);\n\n  return JsonEncoder;\n}();\n\nvar JsonDecoder = exports.JsonDecoder = function () {\n  function JsonDecoder() {\n    _classCallCheck(this, JsonDecoder);\n  }\n\n  _createClass(JsonDecoder, [{\n    key: 'decodeReplies',\n    value: function decodeReplies(data) {\n      var replies = [];\n      var encodedReplies = data.split('\\n');\n      for (var i in encodedReplies) {\n        if (encodedReplies.hasOwnProperty(i)) {\n          if (!encodedReplies[i]) {\n            continue;\n          }\n          var reply = JSON.parse(encodedReplies[i]);\n          replies.push(reply);\n        }\n      }\n      return replies;\n    }\n  }, {\n    key: 'decodeCommandResult',\n    value: function decodeCommandResult(methodType, data) {\n      return data;\n    }\n  }, {\n    key: 'decodePush',\n    value: function decodePush(data) {\n      return data;\n    }\n  }, {\n    key: 'decodePushData',\n    value: function decodePushData(pushType, data) {\n      return data;\n    }\n  }]);\n\n  return JsonDecoder;\n}();\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n\n/***/ 31:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _centrifuge = __webpack_require__(10);\n\nexports.default = _centrifuge.Centrifuge;\nmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n/***/ }),\n\n/***/ 7:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar startsWith = exports.startsWith = function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nvar isString = exports.isString = function isString(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'string' || value instanceof String;\n};\n\nvar isFunction = exports.isFunction = function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nvar log = exports.log = function log(level, args) {\n  if (global.console) {\n    var logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nvar backoff = exports.backoff = function backoff(step, min, max) {\n  var jitter = 0.5 * Math.random();\n  var interval = min * Math.pow(2, step + 1);\n\n  if (interval > max) {\n    interval = max;\n  }\n  return Math.floor((1 - jitter) * interval);\n};\n\nvar errorExists = exports.errorExists = function errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// centrifuge.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 31);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bc4da11a9a456f27ec97","import EventEmitter from 'events';\nimport Subscription from './subscription';\n\nimport {\n  JsonEncoder,\n  JsonDecoder,\n  JsonMethodType,\n  JsonPushType\n} from './json';\n\nimport {\n  isFunction,\n  isString,\n  log,\n  startsWith,\n  errorExists,\n  backoff\n} from './utils';\n\nconst _errorTimeout = 'timeout';\n\nexport class Centrifuge extends EventEmitter {\n\n  constructor(url, options) {\n    super();\n    this._url = url;\n    this._promise = null;\n    this._sockjs = null;\n    this._isSockjs = false;\n    this._binary = false;\n    this._methodType = null;\n    this._pushType = null;\n    this._encoder = null;\n    this._decoder = null;\n    this._status = 'disconnected';\n    this._reconnect = true;\n    this._reconnecting = false;\n    this._transport = null;\n    this._transportName = null;\n    this._transportClosed = true;\n    this._messageId = 0;\n    this._clientID = null;\n    this._subs = {};\n    this._lastPubUID = {};\n    this._messages = [];\n    this._isBatching = false;\n    this._isAuthBatching = false;\n    this._authChannels = {};\n    this._numRefreshFailed = 0;\n    this._refreshTimeout = null;\n    this._pingInterval = null;\n    this._pongTimeout = null;\n    this._retries = 0;\n    this._callbacks = {};\n    this._latency = null;\n    this._latencyStart = null;\n    this._credentials = null;\n    this._config = {\n      debug: false,\n      sockjs: null,\n      promise: null,\n      retry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      resubscribe: true,\n      ping: true,\n      pingInterval: 30000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: [\n        'websocket',\n        'xdr-streaming',\n        'xhr-streaming',\n        'eventsource',\n        'iframe-eventsource',\n        'iframe-htmlfile',\n        'xdr-polling',\n        'xhr-polling',\n        'iframe-xhr-polling',\n        'jsonp-polling'\n      ],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 3000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      authEndpoint: '/centrifuge/auth',\n      authHeaders: {},\n      authParams: {},\n      onAuth: null\n    };\n    this._configure(options);\n  }\n\n  setCredentials(credentials) {\n    this._credentials = credentials;\n  }\n\n  _ajax(url, params, headers, data, callback) {\n    var self = this;\n    var query = '';\n\n    self._debug('sending AJAX request to', url);\n\n    const xhr = (global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP'));\n\n    for (let i in params) {\n      if (params.hasOwnProperty(i)) {\n        if (query.length > 0) {\n          query += '&';\n        }\n        query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n      }\n    }\n    if (query.length > 0) {\n      query = '?' + query;\n    }\n    xhr.open('POST', url + query, true);\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    for (let headerName in headers) {\n      if (headers.hasOwnProperty(headerName)) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          let data, parsed = false;\n\n          try {\n            data = JSON.parse(xhr.responseText);\n            parsed = true;\n          } catch (e) {\n            callback(true, 'JSON returned was invalid, yet status code was 200. Data was: ' + xhr.responseText);\n          }\n          if (parsed) { // prevents double execution.\n            callback(false, data);\n          }\n        } else {\n          self._log(\"Couldn't get auth info from application\", xhr.status);\n          callback(true, xhr.status);\n        }\n      }\n    };\n\n    setTimeout(function () {\n      xhr.send(JSON.stringify(data));\n    }, 20);\n    return xhr;\n  };\n\n  _log() {\n    log('info', arguments);\n  };\n\n  _debug() {\n    if (this._config.debug === true) {\n      log('debug', arguments);\n    }\n  };\n\n  _websocketSupported() {\n    return !(typeof WebSocket !== 'function' && typeof WebSocket !== 'object');\n  };\n\n  _setFormat(format) {\n    if (this._formatOverride(format)) {\n      return;\n    }\n    if (format === 'protobuf') {\n      throw new Error('not implemented by JSON only Centrifuge client – use client with Protobuf');\n    }\n    this._binary = false;\n    this._methodType = JsonMethodType;\n    this._pushType = JsonPushType;\n    this._encoder = new JsonEncoder();\n    this._decoder = new JsonDecoder();\n  }\n\n  _formatOverride(format) {\n    return false;\n  }\n\n  _configure(configuration) {\n    Object.assign(this._config, configuration || {});\n    this._debug('centrifuge config', this._config);\n\n    if (!this._url) {\n      throw new Error('url required');\n    }\n\n    if (this._config.promise !== null) {\n      this._promise = this._config.promise;\n    } else {\n      if (!global.Promise) {\n        throw new Error('Promise polyfill required');\n      }\n      this._promise = global.Promise;\n    }\n\n    if (startsWith(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n      this._setFormat('protobuf');\n    } else {\n      this._setFormat('json');\n    }\n\n    if (startsWith(this._url, 'http')) {\n      this._debug('client will try to connect to SockJS endpoint');\n      if (this._config.sockjs !== null) {\n        this._debug('SockJS explicitly provided in options');\n        this._sockjs = this._config.sockjs;\n      } else {\n        if (typeof global.SockJS === 'undefined') {\n          throw new Error('SockJS not found, use ws:// in url or include SockJS');\n        }\n        this._debug('use globally defined SockJS');\n        this._sockjs = global.SockJS;\n      }\n    } else {\n      this._debug('client will connect to websocket endpoint');\n    }\n  };\n\n  _setStatus(newStatus) {\n    if (this._status !== newStatus) {\n      this._debug('Status', this._status, '->', newStatus);\n      this._status = newStatus;\n    }\n  };\n\n  _isDisconnected() {\n    return this._status === 'disconnected';\n  };\n\n  _isConnecting() {\n    return this._status === 'connecting';\n  };\n\n  _isConnected() {\n    return this._status === 'connected';\n  };\n\n  _nextMessageId() {\n    return ++this._messageId;\n  };\n\n  _resetRetry() {\n    this._debug('reset retries count to 0');\n    this._retries = 0;\n  };\n\n  _getRetryInterval() {\n    var interval = backoff(this._retries, this._config.retry, this._config.maxRetry);\n\n    this._retries += 1;\n    return interval;\n  };\n\n  _clearConnectedState(reconnect) {\n    this._clientID = null;\n\n    // fire errbacks of registered outgoing calls.\n    for (let uid in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(uid)) {\n        const callbacks = this._callbacks[uid];\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback(this._createErrorObject('disconnected'));\n      }\n    }\n    this._callbacks = {};\n\n    // fire unsubscribe events\n    for (let channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n\n        if (reconnect) {\n          if (sub._isSuccess()) {\n            sub._triggerUnsubscribe();\n          }\n          sub._setSubscribing();\n        } else {\n          sub._setUnsubscribed();\n        }\n      }\n    }\n\n    if (!this._config.resubscribe || !this._reconnect) {\n      // completely clear connected state\n      this._subs = {};\n    }\n  };\n\n  _transportSend(commands) {\n    if (!commands.length) {\n      return;\n    }\n    if (!this._transport) {\n      throw new Error('transport not connected');\n    }\n    this._transport.send(this._encoder.encodeCommands(commands));\n  }\n\n  _setupTransport() {\n    var self = this;\n    this._isSockjs = false;\n\n    // detect transport to use - SockJS or Websocket\n    if (this._sockjs !== null) {\n      const sockjsOptions = {\n        transports: this._config.sockjsTransports\n      };\n\n      if (this._config.sockjsServer !== null) {\n        sockjsOptions.server = this._config.sockjsServer;\n      }\n      this._isSockjs = true;\n      this._transport = new this._sockjs(this._url, null, sockjsOptions);\n    } else {\n      if (!this._websocketSupported()) {\n        this._debug('No Websocket support and no SockJS configured, can not connect');\n        return;\n      }\n      this._transport = new WebSocket(this._url);\n      if (this._binary === true) {\n        this._transport.binaryType = 'arraybuffer';\n      }\n    }\n\n    this._transport.onopen = function () {\n      self._transportClosed = false;\n      self._reconnecting = false;\n      if (self._isSockjs) {\n        self._transportName = 'sockjs-' + self._transport.transport;\n        self._transport.onheartbeat = function () {\n          self._restartPing();\n        };\n      } else {\n        self._transportName = 'websocket';\n      }\n\n      self._resetRetry();\n\n      // Can omit method here due to zero value.\n      let msg = {\n        // method: self._methodType.CONNECT\n      };\n\n      if (self._credentials) {\n        msg.params = self._credentials;\n      }\n\n      self._latencyStart = new Date();\n      self._call(msg).then(function (result) {\n        self._connectResponse(self._decoder.decodeCommandResult(self._methodType.CONNECT, result));\n      }, function () {\n        self._disconnect('connect error', true);\n      });\n    };\n\n    this._transport.onerror = function (error) {\n      self._debug('transport level error', error);\n    };\n\n    this._transport.onclose = function (closeEvent) {\n      self._transportClosed = true;\n      let reason = 'connection closed';\n      let needReconnect = true;\n\n      if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n        try {\n          const advice = JSON.parse(closeEvent.reason);\n\n          self._debug('reason is an advice object', advice);\n          reason = advice.reason;\n          needReconnect = advice.reconnect;\n        } catch (e) {\n          reason = closeEvent.reason;\n          self._debug('reason is a plain string', reason);\n          needReconnect = reason !== 'disconnect';\n        }\n      }\n\n      // onTransportClose callback should be executed every time transport was closed.\n      // This can be helpful to catch failed connection events (because our disconnect\n      // event only called once and every future attempts to connect do not fire disconnect\n      // event again).\n      if (self._config.onTransportClose !== null) {\n        self._config.onTransportClose({\n          event: closeEvent,\n          reason: reason,\n          reconnect: needReconnect\n        });\n      }\n\n      self._disconnect(reason, needReconnect);\n\n      if (self._reconnect === true) {\n        self._reconnecting = true;\n        const interval = self._getRetryInterval();\n\n        self._debug('reconnect after ' + interval + ' milliseconds');\n        setTimeout(function () {\n          if (self._reconnect === true) {\n            self._connect.call(self);\n          }\n        }, interval);\n      }\n    };\n\n    this._transport.onmessage = function (event) {\n      const replies = self._decoder.decodeReplies(event.data);\n      for (let i in replies) {\n        if (replies.hasOwnProperty(i)) {\n          self._debug('Received reply', replies[i]);\n          self._dispatchReply(replies[i]);\n        }\n      }\n      self._restartPing();\n    };\n  };\n\n  rpc(data) {\n    const self = this;\n    const msg = {\n      method: self._methodType.RPC,\n      params: {\n        data: data\n      }\n    };\n    const promise = this._call(msg);\n\n    return new self._promise(function (resolve, reject) {\n      promise.then(function (result) {\n        resolve(self._decoder.decodeCommandResult(self._methodType.RPC, result));\n      }, function (error) {\n        reject(error);\n      });\n    });\n  }\n\n  send(data) {\n    const msg = {\n      method: this._methodType.SEND,\n      params: {\n        data: data\n      }\n    };\n\n    return this._callAsync(msg);\n  }\n\n  _callAsync(msg) {\n    this._addMessage(msg, true);\n  }\n\n  _call(msg) {\n    var self = this;\n\n    return new self._promise(function (resolve, reject) {\n      const id = self._addMessage(msg);\n      self._registerCall(id, resolve, reject);\n    });\n  }\n\n  _connect() {\n    if (this.isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._status === 'connecting') {\n      return;\n    }\n\n    this._debug('start connecting');\n    this._setStatus('connecting');\n    this._clientID = null;\n    this._reconnect = true;\n    this._setupTransport();\n  };\n\n  _disconnect(reason, shouldReconnect) {\n\n    if (this._isDisconnected()) {\n      return;\n    }\n\n    this._debug('disconnected:', reason, shouldReconnect);\n\n    const reconnect = shouldReconnect || false;\n\n    if (reconnect === false) {\n      this._reconnect = false;\n    }\n\n    this._clearConnectedState(reconnect);\n\n    if (!this._isDisconnected()) {\n      this._setStatus('disconnected');\n      if (this._refreshTimeout) {\n        clearTimeout(this._refreshTimeout);\n      }\n      if (this._reconnecting === false) {\n        this.emit('disconnect', {\n          reason: reason,\n          reconnect: reconnect\n        });\n      }\n    }\n\n    if (!this._transportClosed) {\n      this._transport.close();\n    }\n  };\n\n  _refreshFailed() {\n    this._numRefreshFailed = 0;\n    if (!this._isDisconnected()) {\n      this._disconnect('refresh failed', false);\n    }\n    if (this._config.onRefreshFailed !== null) {\n      this._config.onRefreshFailed();\n    }\n  };\n\n  _refresh() {\n    // ask web app for connection parameters - user ID,\n    // timestamp, info and token\n    var self = this;\n\n    this._debug('refresh credentials');\n\n    if (self._config.refreshAttempts === 0) {\n      this._debug('refresh attempts set to 0, do not send refresh request at all');\n      self._refreshFailed();\n      return;\n    }\n\n    if (self._refreshTimeout !== null) {\n      clearTimeout(self._refreshTimeout);\n    }\n\n    const cb = function (error, data) {\n      if (error === true) {\n        // We don't perform any connection status related actions here as we are\n        // relying on Centrifugo that must close connection eventually.\n        self._debug('error getting connection credentials from refresh endpoint', data);\n        self._numRefreshFailed++;\n        if (self._refreshTimeout) {\n          clearTimeout(self._refreshTimeout);\n        }\n        if (self._config.refreshAttempts !== null && self._numRefreshFailed >= self._config.refreshAttempts) {\n          self._refreshFailed();\n          return;\n        }\n        self._refreshTimeout = setTimeout(function () {\n          self._refresh.call(self);\n        }, self._config.refreshInterval + Math.round(Math.random() * 1000));\n        return;\n      }\n      self._numRefreshFailed = 0;\n      if (self._credentials === null) {\n        return;\n      }\n      self._credentials.user = data.user;\n      self._credentials.exp = data.exp;\n      if ('info' in data) {\n        self._credentials.info = data.info;\n      }\n      self._credentials.sign = data.sign;\n      if (self._isDisconnected()) {\n        self._debug('credentials refreshed, connect from scratch');\n        self._connect();\n      } else {\n        self._debug('send refreshed credentials');\n\n        const msg = {\n          method: self._methodType.REFRESH,\n          params: self._credentials\n        };\n\n        self._call(msg).then(function (result) {\n          self._refreshResponse(self._decoder.decodeCommandResult(self._methodType.REFRESH, result));\n        }, function () {\n          self._disconnect('refresh error', true);\n        });\n      }\n    };\n\n    if (this._config.onRefresh !== null) {\n      const context = {};\n      this._config.onRefresh(context, cb);\n    } else {\n      this._ajax(\n        this._config.refreshEndpoint,\n        this._config.refreshParams,\n        this._config.refreshHeaders,\n        this._config.refreshData,\n        cb\n      );\n    }\n  };\n\n  _subscribe(sub) {\n\n    const channel = sub.channel;\n\n    if (!(channel in this._subs)) {\n      this._subs[channel] = sub;\n    }\n\n    if (!this.isConnected()) {\n      // subscribe will be called later\n      sub._setNew();\n      return;\n    }\n\n    sub._setSubscribing();\n\n    const msg = {\n      method: this._methodType.SUBSCRIBE,\n      params: {\n        channel: channel\n      }\n    };\n\n    // If channel name does not start with privateChannelPrefix - then we\n    // can just send subscription message to Centrifuge. If channel name\n    // starts with privateChannelPrefix - then this is a private channel\n    // and we should ask web application backend for permission first.\n    if (startsWith(channel, this._config.privateChannelPrefix)) {\n      // private channel\n      if (this._isAuthBatching) {\n        this._authChannels[channel] = true;\n      } else {\n        this.startAuthBatching();\n        this._subscribe(sub);\n        this.stopAuthBatching();\n      }\n    } else {\n      const recover = this._recover(channel);\n\n      if (recover === true) {\n        msg.params.recover = true;\n        msg.params.last = this._getLastID(channel);\n      }\n      const self = this;\n\n      this._call(msg).then(function (result) {\n        self._subscribeResponse(channel, self._decoder.decodeCommandResult(self._methodType.SUBSCRIBE, result));\n      }, function (err) {\n        self._subscribeError(err);\n      });\n    }\n  };\n\n  _unsubscribe(sub) {\n    if (this.isConnected()) {\n      // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n      this._addMessage({\n        method: this._methodType.UNSUBSCRIBE,\n        params: {\n          channel: sub.channel\n        }\n      });\n    }\n  };\n\n  getSub(channel) {\n    return this._getSub(channel);\n  }\n\n  _getSub(channel) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  };\n\n  _connectResponse(result) {\n    if (this.isConnected()) {\n      return;\n    }\n\n    if (this._latencyStart !== null) {\n      this._latency = (new Date()).getTime() - this._latencyStart.getTime();\n      this._latencyStart = null;\n    }\n\n    if (result.expires) {\n      const isExpired = result.expired;\n\n      if (isExpired) {\n        this._reconnecting = true;\n        this._disconnect('expired', true);\n        this._refresh();\n        return;\n      }\n    }\n    this._clientID = result.client;\n    this._setStatus('connected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n\n    const self = this;\n\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(function () {\n        self._refresh.call(self);\n      }, result.ttl * 1000);\n    }\n\n    if (this._config.resubscribe) {\n      this.startBatching();\n      this.startAuthBatching();\n      for (let channel in this._subs) {\n        if (this._subs.hasOwnProperty(channel)) {\n          const sub = this._subs[channel];\n          if (sub._shouldResubscribe()) {\n            this._subscribe(sub);\n          }\n        }\n      }\n      this.stopAuthBatching();\n      this.stopBatching(true);\n    }\n\n    this._restartPing();\n    this.emit('connect', {\n      client: result.client,\n      transport: this._transportName,\n      latency: this._latency\n    });\n  };\n\n  _stopPing() {\n    if (this._pongTimeout !== null) {\n      clearTimeout(this._pongTimeout);\n    }\n    if (this._pingInterval !== null) {\n      clearInterval(this._pingInterval);\n    }\n  };\n\n  _startPing() {\n    if (this._config.ping !== true || this._config.pingInterval <= 0) {\n      return;\n    }\n    if (!this.isConnected()) {\n      return;\n    }\n\n    const self = this;\n\n    this._pingInterval = setInterval(function () {\n      if (!self.isConnected()) {\n        self._stopPing();\n        return;\n      }\n      self.ping();\n      self._pongTimeout = setTimeout(function () {\n        self._disconnect('no ping', true);\n      }, self._config.pongWaitTimeout);\n    }, this._config.pingInterval);\n  };\n\n  _restartPing() {\n    this._stopPing();\n    this._startPing();\n  };\n\n  _subscribeError(channel, error) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    if (error.code === 0 && error.message === _errorTimeout) { // client side timeout.\n      this._disconnect('timeout', true);\n      return;\n    }\n    sub._setSubscribeError(error);\n  };\n\n  _subscribeResponse(channel, result) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n\n    let pubs = result.publications;\n\n    if (pubs && pubs.length > 0) {\n      // handle missed pubs.\n      pubs = pubs.reverse();\n      for (let i in pubs) {\n        if (pubs.hasOwnProperty(i)) {\n          this._handlePublication(channel, pubs[i]);\n        }\n      }\n    } else {\n      if ('last' in result) {\n        // no missed messages found so set last message id from result.\n        this._lastPubUID[channel] = result.last;\n      }\n    }\n\n    let recovered = false;\n\n    if ('recovered' in result) {\n      recovered = result.recovered;\n    }\n    sub._setSubscribeSuccess(recovered);\n  };\n\n  _handleReply(reply) {\n    const id = reply.id;\n    const result = reply.result;\n\n    if (!(id in this._callbacks)) {\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback(result);\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        return;\n      }\n      errback(reply.error);\n    }\n  }\n\n  _handleJoin(channel, join) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    sub.emit('join', join);\n  };\n\n  _handleLeave(channel, leave) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    sub.emit('leave', leave);\n  };\n\n  _handleUnsub(channel) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    sub.unsubscribe();\n  };\n\n  _handlePublication(channel, pub) {\n    // keep last uid received from channel.\n    this._lastPubUID[channel] = pub.uid;\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    sub.emit('publication', pub);\n  };\n\n  _handleMessage(message) {\n    this.emit('message', message.data);\n  };\n\n  _refreshResponse(result) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n    if (result.expires) {\n      const self = this;\n      const expired = result.expired;\n\n      if (expired) {\n        self._refreshTimeout = setTimeout(function () {\n          self._refresh.call(self);\n        }, self._config.refreshInterval + Math.round(Math.random() * 1000));\n        return;\n      }\n      this._clientID = result.client;\n      self._refreshTimeout = setTimeout(function () {\n        self._refresh.call(self);\n      }, result.ttl * 1000);\n    }\n  };\n\n  _handlePush(data) {\n    const push = this._decoder.decodePush(data);\n    let type = 0;\n    if ('type' in push) {\n      type = push['type'];\n    }\n    const channel = push.channel;\n\n    if (type === this._pushType.PUBLICATION) {\n      const pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n      this._handlePublication(channel, pub);\n    } else if (type === this._pushType.MESSAGE) {\n      const message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n      this._handleMessage(message);\n    } else if (type === this._pushType.JOIN) {\n      const join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n      this._handleJoin(channel, join);\n    } else if (type === this._pushType.LEAVE) {\n      const leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n      this._handleLeave(channel, leave);\n    } else if (type === this._pushType.UNSUB) {\n      this._handleUnsub(channel);\n    }\n  }\n\n  _dispatchReply(reply) {\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      return;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply);\n    } else {\n      this._handlePush(reply.result);\n    }\n  };\n\n  _flush() {\n    const messages = this._messages.slice(0);\n    this._messages = [];\n    this._transportSend(messages);\n  };\n\n  _ping() {\n    this._addMessage({\n      method: this._methodType.PING\n    });\n  };\n\n  _recover(channel) {\n    return channel in this._lastPubUID;\n  };\n\n  _getLastID(channel) {\n    const lastUID = this._lastPubUID[channel];\n\n    if (lastUID) {\n      this._debug('last uid found and sent for channel', channel);\n      return lastUID;\n    }\n    this._debug('no last uid found for channel', channel);\n    return '';\n\n  };\n\n  _createErrorObject(message, code) {\n    const errObject = {\n      message: message,\n      code: code || 0\n    };\n\n    return errObject;\n  };\n\n  _registerCall(id, callback, errback) {\n    const self = this;\n\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback\n    };\n    setTimeout(function () {\n      delete self._callbacks[id];\n      if (isFunction(errback)) {\n        errback(self._createErrorObject(_errorTimeout));\n      }\n    }, this._config.timeout);\n  };\n\n  _addMessage(message, async) {\n    let id;\n    if (!async) {\n      id = this._nextMessageId();\n      message.id = id;\n    }\n    if (this._isBatching === true) {\n      this._messages.push(message);\n    } else {\n      this._transportSend([message]);\n    }\n    if (!async) {\n      return id;\n    }\n    return 0;\n  };\n\n  isConnected() {\n    return this._isConnected();\n  }\n\n  connect() {\n    this._connect();\n  };\n\n  disconnect() {\n    this._disconnect('client', false);\n  };\n\n  ping() {\n    return this._ping();\n  }\n\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._isBatching = true;\n  };\n\n  stopBatching(flush) {\n    // stop collecting messages\n    flush = flush || false;\n    this._isBatching = false;\n    if (flush === true) {\n      this.flush();\n    }\n  };\n\n  flush() {\n    // send batched messages to Centrifuge\n    this._flush();\n  };\n\n  startAuthBatching() {\n    // start collecting private channels to create bulk authentication\n    // request to authEndpoint when stopAuthBatching will be called\n    this._isAuthBatching = true;\n  };\n\n  stopAuthBatching() {\n    var i,\n      channel;\n\n    // create request to authEndpoint with collected private channels\n    // to ask if this client can subscribe on each channel\n    this._isAuthBatching = false;\n    const authChannels = this._authChannels;\n\n    this._authChannels = {};\n    const channels = [];\n\n    for (channel in authChannels) {\n      if (authChannels.hasOwnProperty(channel)) {\n        const sub = this._getSub(channel);\n\n        if (!sub) {\n          continue;\n        }\n        channels.push(channel);\n      }\n    }\n\n    if (channels.length === 0) {\n      return;\n    }\n\n    const data = {\n      client: this._clientID,\n      channels: channels\n    };\n\n    const self = this;\n\n    const cb = function (error, data) {\n      if (error === true) {\n        self._debug('authorization request failed');\n        for (i in channels) {\n          if (channels.hasOwnProperty(i)) {\n            channel = channels[i];\n            self._subscribeResponse({\n              error: 'authorization request failed',\n              body: {\n                channel: channel\n              }\n            });\n          }\n        }\n        return;\n      }\n\n      // try to send all subscriptions in one request.\n      let batch = false;\n\n      if (!self._isBatching) {\n        self.startBatching();\n        batch = true;\n      }\n\n      for (i in channels) {\n        if (channels.hasOwnProperty(i)) {\n          channel = channels[i];\n          const channelResponse = data[channel];\n\n          if (!channelResponse) {\n            // subscription:error\n            self._subscribeResponse({\n              error: 'channel not found in authorization response',\n              body: {\n                channel: channel\n              }\n            });\n            continue;\n          }\n          if (!channelResponse.status || channelResponse.status === 200) {\n            const msg = {\n              method: self._methodType.SUBSCRIBE,\n              params: {\n                channel: channel,\n                client: self._clientID,\n                info: channelResponse.info,\n                sign: channelResponse.sign\n              }\n            };\n            const recover = self._recover(channel);\n\n            if (recover === true) {\n              msg.params.recover = true;\n              msg.params.last = self._getLastID(channel);\n            }\n            self._call(msg).then(function (result) {\n              self._subscribeResponse(channel, self._decoder.decodeCommandResult(self._methodType.SUBSCRIBE, result));\n            }, function (err) {\n              self._subscribeError(channel, err);\n            });\n          } else {\n            self._subscribeResponse({\n              error: channelResponse.status,\n              body: {\n                channel: channel\n              }\n            });\n          }\n        }\n      }\n\n      if (batch) {\n        self.stopBatching(true);\n      }\n\n    };\n\n    if (this._config.onAuth !== null) {\n      this._config.onAuth({\n        data: data\n      }, cb);\n    } else {\n      this._ajax(this._config.authEndpoint, this._config.authParams, this._config.authHeaders, data, cb);\n    }\n  };\n\n  subscribe(channel, events) {\n    if (arguments.length < 1) {\n      throw new Error('Illegal arguments number: required 1, got ' + arguments.length);\n    }\n    if (!isString(channel)) {\n      throw new Error('Illegal argument type: channel must be a string');\n    }\n    if (!this._config.resubscribe && !this.isConnected()) {\n      throw new Error('Can not only subscribe in connected state when resubscribe option is off');\n    }\n\n    const currentSub = this._getSub(channel);\n\n    if (currentSub !== null) {\n      currentSub._setEvents(events);\n      if (currentSub._isUnsubscribed()) {\n        currentSub.subscribe();\n      }\n      return currentSub;\n    }\n    const sub = new Subscription(this, channel, events);\n    this._subs[channel] = sub;\n    sub.subscribe();\n    return sub;\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/centrifuge.js","import EventEmitter from 'events';\n\nimport {\n  isFunction\n} from './utils';\n\nconst _STATE_NEW = 0;\nconst _STATE_SUBSCRIBING = 1;\nconst _STATE_SUCCESS = 2;\nconst _STATE_ERROR = 3;\nconst _STATE_UNSUBSCRIBED = 4;\n\nexport default class Subscription extends EventEmitter {\n  constructor(centrifuge, channel, events) {\n    super();\n    this.channel = channel;\n    this._centrifuge = centrifuge;\n    this._status = _STATE_NEW;\n    this._error = null;\n    this._isResubscribe = false;\n    this._recovered = false;\n    this._ready = false;\n    this._promise = null;\n    this._noResubscribe = false;\n    this._setEvents(events);\n    this._initializePromise();\n  }\n\n  _initializePromise() {\n    // this helps us to wait until subscription will successfully\n    // subscribe and call actions such as presence, history etc in\n    // synchronous way.\n    var self = this;\n\n    this._ready = false;\n\n    this._promise = new Promise(function (resolve, reject) {\n      self._resolve = function (value) {\n        self._ready = true;\n        resolve(value);\n      };\n      self._reject = function (err) {\n        self._ready = true;\n        reject(err);\n      };\n    });\n  };\n\n  _setEvents(events) {\n    if (!events) {\n      return;\n    }\n    if (isFunction(events)) {\n      // events is just a function to handle publication received from channel.\n      this.on('publication', events);\n    } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n      const knownEvents = ['publication', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n      for (let i = 0, l = knownEvents.length; i < l; i++) {\n        const ev = knownEvents[i];\n        if (ev in events) {\n          this.on(ev, events[ev]);\n        }\n      }\n    }\n  };\n\n  _isNew() {\n    return this._status === _STATE_NEW;\n  };\n\n  _isUnsubscribed() {\n    return this._status === _STATE_UNSUBSCRIBED;\n  };\n\n  _isSubscribing() {\n    return this._status === _STATE_SUBSCRIBING;\n  };\n\n  _isReady() {\n    return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n  };\n\n  _isSuccess() {\n    return this._status === _STATE_SUCCESS;\n  };\n\n  _isError() {\n    return this._status === _STATE_ERROR;\n  };\n\n  _setNew() {\n    this._status = _STATE_NEW;\n  };\n\n  _setSubscribing() {\n    if (this._ready === true) {\n      // new promise for this subscription\n      this._initializePromise();\n      this._isResubscribe = true;\n    }\n    this._status = _STATE_SUBSCRIBING;\n  };\n\n  _setSubscribeSuccess(recovered) {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._recovered = recovered;\n    this._status = _STATE_SUCCESS;\n    const successContext = this._getSubscribeSuccessContext(recovered);\n\n    this.emit('subscribe', successContext);\n    this._resolve(successContext);\n  };\n\n  _setSubscribeError(err) {\n    if (this._status === _STATE_ERROR) {\n      return;\n    }\n    this._status = _STATE_ERROR;\n    this._error = err;\n    const errContext = this._getSubscribeErrorContext();\n\n    this.emit('error', errContext);\n    this._reject(errContext);\n  };\n\n  _triggerUnsubscribe() {\n    this.emit('unsubscribe', {\n      channel: this.channel\n    });\n  };\n\n  _setUnsubscribed(noResubscribe) {\n    if (this._status === _STATE_UNSUBSCRIBED) {\n      return;\n    }\n    const needTrigger = this._status === _STATE_SUCCESS;\n    this._status = _STATE_UNSUBSCRIBED;\n    if (noResubscribe === true) {\n      this._noResubscribe = true;\n    }\n    if (needTrigger) {\n      this._triggerUnsubscribe();\n    }\n  };\n\n  _shouldResubscribe() {\n    return !this._noResubscribe;\n  };\n\n  _getSubscribeSuccessContext() {\n    return {\n      channel: this.channel,\n      isResubscribe: this._isResubscribe,\n      recovered: this._recovered\n    };\n  };\n\n  _getSubscribeErrorContext() {\n    let subscribeErrorContext = this._error;\n    subscribeErrorContext.channel = this.channel;\n    subscribeErrorContext.isResubscribe = this._isResubscribe;\n    return subscribeErrorContext;\n  };\n\n  ready(callback, errback) {\n    if (this._ready) {\n      if (this._isSuccess()) {\n        callback(this._getSubscribeSuccessContext());\n      } else {\n        errback(this._getSubscribeErrorContext());\n      }\n    }\n  };\n\n  subscribe() {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._centrifuge._subscribe(this);\n  };\n\n  unsubscribe() {\n    this._setUnsubscribed(true);\n    this._centrifuge._unsubscribe(this);\n  };\n\n  _methodCall(message, type) {\n    var self = this;\n    return new self._centrifuge._promise(function (resolve, reject) {\n      self._promise.then(function () {\n        self._centrifuge._call(message).then(function (result) {\n          resolve(self._centrifuge._decoder.decodeCommandResult(type, result));\n        }, function (err) {\n          reject(err);\n        });\n      }, function (err) {\n        reject(err);\n      });\n    });\n  }\n\n  publish(data) {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PUBLISH,\n      params: {\n        channel: self.channel,\n        data: data\n      }\n    }, this._centrifuge._methodType.PUBLISH);\n  };\n\n  presence() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE,\n      params: {\n        channel: self.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE);\n  };\n\n  presenceStats() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.PRESENCE_STATS,\n      params: {\n        channel: self.channel\n      }\n    }, this._centrifuge._methodType.PRESENCE_STATS);\n  };\n\n  history() {\n    return this._methodCall({\n      method: this._centrifuge._methodType.HISTORY,\n      params: {\n        channel: self.channel\n      }\n    }, this._centrifuge._methodType.HISTORY);\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/subscription.js","export const JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10\n};\n\nexport const JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4\n};\n\nexport class JsonEncoder {\n  encodeCommands(commands) {\n    const encodedCommands = [];\n    for (const i in commands) {\n      if (commands.hasOwnProperty(i)) {\n        encodedCommands.push(JSON.stringify(commands[i]));\n      }\n    }\n    return encodedCommands.join('\\n');\n  }\n}\n\nexport class JsonDecoder {\n  decodeReplies(data) {\n    let replies = [];\n    const encodedReplies = data.split('\\n');\n    for (let i in encodedReplies) {\n      if (encodedReplies.hasOwnProperty(i)) {\n        if (!encodedReplies[i]) {\n          continue;\n        }\n        const reply = JSON.parse(encodedReplies[i]);\n        replies.push(reply);\n      }\n    }\n    return replies;\n  }\n\n  decodeCommandResult(methodType, data) {\n    return data;\n  }\n\n  decodePush(data) {\n    return data;\n  }\n\n  decodePushData(pushType, data) {\n    return data;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/json.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 0 1","import {Centrifuge} from './centrifuge.js';\nexport default Centrifuge;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/events/events.js\n// module id = 6\n// module chunks = 0 1","export const startsWith = function (value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nexport const isString = function (value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'string' || value instanceof String;\n};\n\nexport const isFunction = function (value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nexport const log = function (level, args) {\n  if (global.console) {\n    const logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nexport const backoff = function (step, min, max) {\n  var jitter = 0.5 * Math.random();\n  var interval = min * Math.pow(2, step + 1);\n\n  if (interval > max) {\n    interval = max;\n  }\n  return Math.floor((1 - jitter) * interval);\n};\n\nexport const errorExists = function (data) {\n  return 'error' in data && data.error !== null;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}